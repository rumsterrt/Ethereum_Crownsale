[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n/* Package-scope variables */\nvar BigNumber;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                           //\n// packages/3stack_bignumber/packages/3stack_bignumber.js                                                    //\n//                                                                                                           //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                             //\n(function () {                                                                                               // 1\n                                                                                                             // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////      // 3\n//                                                                                                   //      // 4\n// packages/3stack:bignumber/bignumber.js                                                            //      // 5\n//                                                                                                   //      // 6\n///////////////////////////////////////////////////////////////////////////////////////////////////////      // 7\n                                                                                                     //      // 8\n/*! bignumber.js v2.0.0 https://github.com/MikeMcl/bignumber.js/LICENCE */                           // 1    // 9\n                                                                                                     // 2    // 10\nBigNumber = (function () {                                                                           // 3    // 11\n    'use strict';                                                                                    // 4    // 12\n                                                                                                     // 5    // 13\n    /*                                                                                               // 6    // 14\n      bignumber.js v2.0.0                                                                            // 7    // 15\n      A JavaScript library for arbitrary-precision arithmetic.                                       // 8    // 16\n      https://github.com/MikeMcl/bignumber.js                                                        // 9    // 17\n      Copyright (c) 2014 Michael Mclaughlin <M8ch88l@gmail.com>                                      // 10   // 18\n      MIT Expat Licence                                                                              // 11   // 19\n    */                                                                                               // 12   // 20\n                                                                                                     // 13   // 21\n    /*********************************** DEFAULTS ************************************/              // 14   // 22\n                                                                                                     // 15   // 23\n    /*                                                                                               // 16   // 24\n     * The default values below must be integers within the inclusive ranges stated.                 // 17   // 25\n     * Most of these values can be changed at run-time using the BigNumber.config method.            // 18   // 26\n     */                                                                                              // 19   // 27\n                                                                                                     // 20   // 28\n    /*                                                                                               // 21   // 29\n     * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP,                    // 22   // 30\n     * MAX_EXP, and the argument to toExponential, toFixed, toFormat, and toPrecision,               // 23   // 31\n     * beyond which an exception is thrown (if ERRORS is true).                                      // 24   // 32\n     */                                                                                              // 25   // 33\n    var MAX = 1E9,                                   // 0 to 1e+9                                    // 26   // 34\n                                                                                                     // 27   // 35\n        // Limit of magnitude of exponent argument to toPower.                                       // 28   // 36\n        MAX_POWER = 1E6,                             // 1 to 1e+6                                    // 29   // 37\n                                                                                                     // 30   // 38\n        // The maximum number of decimal places for operations involving division.                   // 31   // 39\n        DECIMAL_PLACES = 20,                         // 0 to MAX                                     // 32   // 40\n                                                                                                     // 33   // 41\n        /*                                                                                           // 34   // 42\n         * The rounding mode used when rounding to the above decimal places, and when using          // 35   // 43\n         * toExponential, toFixed, toFormat and toPrecision, and round (default value).              // 36   // 44\n         * UP         0 Away from zero.                                                              // 37   // 45\n         * DOWN       1 Towards zero.                                                                // 38   // 46\n         * CEIL       2 Towards +Infinity.                                                           // 39   // 47\n         * FLOOR      3 Towards -Infinity.                                                           // 40   // 48\n         * HALF_UP    4 Towards nearest neighbour. If equidistant, up.                               // 41   // 49\n         * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.                             // 42   // 50\n         * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.           // 43   // 51\n         * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.                // 44   // 52\n         * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.                // 45   // 53\n         */                                                                                          // 46   // 54\n        ROUNDING_MODE = 4,                           // 0 to 8                                       // 47   // 55\n                                                                                                     // 48   // 56\n        // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]                                                // 49   // 57\n                                                                                                     // 50   // 58\n        // The exponent value at and beneath which toString returns exponential notation.            // 51   // 59\n        // Number type: -7                                                                           // 52   // 60\n        TO_EXP_NEG = -7,                             // 0 to -MAX                                    // 53   // 61\n                                                                                                     // 54   // 62\n        // The exponent value at and above which toString returns exponential notation.              // 55   // 63\n        // Number type: 21                                                                           // 56   // 64\n        TO_EXP_POS = 21,                             // 0 to MAX                                     // 57   // 65\n                                                                                                     // 58   // 66\n        // RANGE : [MIN_EXP, MAX_EXP]                                                                // 59   // 67\n                                                                                                     // 60   // 68\n        // The minimum exponent value, beneath which underflow to zero occurs.                       // 61   // 69\n        // Number type: -324  (5e-324)                                                               // 62   // 70\n        MIN_EXP = -MAX,                              // -1 to -MAX                                   // 63   // 71\n                                                                                                     // 64   // 72\n        // The maximum exponent value, above which overflow to Infinity occurs.                      // 65   // 73\n        // Number type:  308  (1.7976931348623157e+308)                                              // 66   // 74\n        MAX_EXP = MAX,                               // 1 to MAX                                     // 67   // 75\n                                                                                                     // 68   // 76\n        // Whether BigNumber Errors are ever thrown.                                                 // 69   // 77\n        // CHANGE parseInt to parseFloat if changing ERRORS to false.                                // 70   // 78\n        ERRORS = true,                               // true or false                                // 71   // 79\n        parse = parseInt,                            // parseInt or parseFloat                       // 72   // 80\n                                                                                                     // 73   // 81\n        // Format specification for the BigNumber.prototype.toFormat method.                         // 74   // 82\n        FORMAT = {                                                                                   // 75   // 83\n            decimalSeparator: '.',                                                                   // 76   // 84\n            groupSeparator: ',',                                                                     // 77   // 85\n            groupSize: 3,                                                                            // 78   // 86\n            secondaryGroupSize: 0,                                                                   // 79   // 87\n            fractionGroupSeparator: '\\xA0',              // non-breaking space                       // 80   // 88\n            fractionGroupSize: 0                                                                     // 81   // 89\n        },                                                                                           // 82   // 90\n                                                                                                     // 83   // 91\n    /***********************************************************************************/            // 84   // 92\n                                                                                                     // 85   // 93\n        P = BigNumber.prototype,                                                                     // 86   // 94\n        DIGITS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',                 // 87   // 95\n        outOfRange,                                                                                  // 88   // 96\n        id = 0,                                                                                      // 89   // 97\n        mathfloor = Math.floor,                                                                      // 90   // 98\n        isValid = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,                                            // 91   // 99\n        trim = String.prototype.trim || function () {return this.replace(/^\\s+|\\s+$/g, '')},         // 92   // 100\n        BASE = 1e14,                                                                                 // 93   // 101\n        LOG_BASE = 14,                                                                               // 94   // 102\n        SQRT_BASE = 1e7,                                                                             // 95   // 103\n        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],          // 96   // 104\n        ONE = new BigNumber(1);                                                                      // 97   // 105\n                                                                                                     // 98   // 106\n                                                                                                     // 99   // 107\n    // CONSTRUCTOR                                                                                   // 100  // 108\n                                                                                                     // 101  // 109\n                                                                                                     // 102  // 110\n    /*                                                                                               // 103  // 111\n     * The exported function.                                                                        // 104  // 112\n     * Create and return a new instance of a BigNumber object.                                       // 105  // 113\n     *                                                                                               // 106  // 114\n     * v {number|string|BigNumber} A numeric value.                                                  // 107  // 115\n     * [b] {number} The base of v. Integer, 2 to 64 inclusive.                                       // 108  // 116\n     */                                                                                              // 109  // 117\n    function BigNumber( n, b ) {                                                                     // 110  // 118\n        var d, e, i, isNum, str, valid,                                                              // 111  // 119\n            x = this;                                                                                // 112  // 120\n                                                                                                     // 113  // 121\n        // Enable constructor usage without new.                                                     // 114  // 122\n        if ( !( x instanceof BigNumber ) ) return new BigNumber( n, b );                             // 115  // 123\n                                                                                                     // 116  // 124\n        // Duplicate.                                                                                // 117  // 125\n        if ( n instanceof BigNumber ) {                                                              // 118  // 126\n                                                                                                     // 119  // 127\n            if ( b == null ) {                                                                       // 120  // 128\n                id = 0;                                                                              // 121  // 129\n                x['s'] = n['s'];                                                                     // 122  // 130\n                x['e'] = n['e'];                                                                     // 123  // 131\n                x['c'] = ( n = n['c'] ) ? n.slice() : n;                                             // 124  // 132\n                return;                                                                              // 125  // 133\n            }                                                                                        // 126  // 134\n            n += '';                                                                                 // 127  // 135\n        } else if ( isNum = ( str = typeof n ) == 'number' ) {                                       // 128  // 136\n                                                                                                     // 129  // 137\n            // Fast path for integers.                                                               // 130  // 138\n            if ( b == null && n === ~~n ) {                                                          // 131  // 139\n                x['s'] = 1 / n < 0 ? ( n = -n, -1 ) : 1;                                             // 132  // 140\n                for ( e = id = 0, i = n; i >= 10; i /= 10, e++ );                                    // 133  // 141\n                x['e'] = e;                                                                          // 134  // 142\n                x['c'] = [n];                                                                        // 135  // 143\n                return;                                                                              // 136  // 144\n            }                                                                                        // 137  // 145\n                                                                                                     // 138  // 146\n            // Minus zero?                                                                           // 139  // 147\n            n = n === 0 && 1 / n < 0 ? '-0' : n + '';                                                // 140  // 148\n        } else if ( str != 'string' ) {                                                              // 141  // 149\n            n += '';                                                                                 // 142  // 150\n        }                                                                                            // 143  // 151\n        str = n;                                                                                     // 144  // 152\n                                                                                                     // 145  // 153\n        if ( b == null && isValid.test(str) ) {                                                      // 146  // 154\n                                                                                                     // 147  // 155\n            // Determine sign.                                                                       // 148  // 156\n            x['s'] = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;                      // 149  // 157\n                                                                                                     // 150  // 158\n        // Either str is not a valid BigNumber or a base has been specified.                         // 151  // 159\n        } else {                                                                                     // 152  // 160\n                                                                                                     // 153  // 161\n            // Enable exponential notation to be used with base 10 argument.                         // 154  // 162\n            // Ensure return value is rounded to DECIMAL_PLACES as with other bases.                 // 155  // 163\n            if ( b == 10 ) {                                                                         // 156  // 164\n                x = new BigNumber(str);                                                              // 157  // 165\n                return rnd( x, DECIMAL_PLACES + x['e'] + 1, ROUNDING_MODE );                         // 158  // 166\n            }                                                                                        // 159  // 167\n            str = trim.call(str).replace( /^\\+(?!-)/, '' );                                          // 160  // 168\n            x['s'] = str.charCodeAt(0) === 45 ? ( str = str.replace( /^-(?!-)/, '' ), -1 ) : 1;      // 161  // 169\n                                                                                                     // 162  // 170\n            if ( b != null ) {                                                                       // 163  // 171\n                                                                                                     // 164  // 172\n                if ( ( b == ~~b || !ERRORS ) && !( outOfRange = !( b >= 2 && b < 65 ) ) ) {          // 165  // 173\n                    d = '[' + DIGITS.slice( 0, b = b | 0 ) + ']+';                                   // 166  // 174\n                                                                                                     // 167  // 175\n                    // Before non-decimal number validity test and base conversion                   // 168  // 176\n                    // remove the `.` from e.g. '1.', and replace e.g. '.1' with '0.1'.              // 169  // 177\n                    str = str.replace( /\\.$/, '' ).replace( /^\\./, '0.' );                           // 170  // 178\n                                                                                                     // 171  // 179\n                    // Any number in exponential form will fail due to the e+/-.                     // 172  // 180\n                    if ( valid = new RegExp( '^' + d + '(?:\\\\.' + d + ')?$',                         // 173  // 181\n                      b < 37 ? 'i' : '' ).test(str) ) {                                              // 174  // 182\n                                                                                                     // 175  // 183\n                        if (isNum) {                                                                 // 176  // 184\n                                                                                                     // 177  // 185\n                            if ( str.replace( /^0\\.0*|\\./, '' ).length > 15 ) {                      // 178  // 186\n                                                                                                     // 179  // 187\n                        // 'new BigNumber() number type has more than 15 significant digits: {n}'    // 180  // 188\n                                ifExceptionsThrow( n, 0 );                                           // 181  // 189\n                            }                                                                        // 182  // 190\n                                                                                                     // 183  // 191\n                            // Prevent later check for length on converted number.                   // 184  // 192\n                            isNum = !isNum;                                                          // 185  // 193\n                        }                                                                            // 186  // 194\n                        str = convertBase( str, 10, b, x['s'] );                                     // 187  // 195\n                    } else if ( str != 'Infinity' && str != 'NaN' ) {                                // 188  // 196\n                                                                                                     // 189  // 197\n                        // 'new BigNumber() not a base {b} number: {str}'                            // 190  // 198\n                        ifExceptionsThrow( n, 1, b );                                                // 191  // 199\n                        n = 'NaN';                                                                   // 192  // 200\n                    }                                                                                // 193  // 201\n                } else {                                                                             // 194  // 202\n                                                                                                     // 195  // 203\n                    // 'new BigNumber() base not an integer: {b}'                                    // 196  // 204\n                    // 'new BigNumber() base out of range: {b}'                                      // 197  // 205\n                    ifExceptionsThrow( b, 2 );                                                       // 198  // 206\n                                                                                                     // 199  // 207\n                    // Ignore base.                                                                  // 200  // 208\n                    valid = isValid.test(str);                                                       // 201  // 209\n                }                                                                                    // 202  // 210\n            } else {                                                                                 // 203  // 211\n                valid = isValid.test(str);                                                           // 204  // 212\n            }                                                                                        // 205  // 213\n                                                                                                     // 206  // 214\n            if ( !valid ) {                                                                          // 207  // 215\n                                                                                                     // 208  // 216\n                // Infinity/NaN                                                                      // 209  // 217\n                x['c'] = x['e'] = null;                                                              // 210  // 218\n                                                                                                     // 211  // 219\n                // NaN                                                                               // 212  // 220\n                if ( str != 'Infinity' ) {                                                           // 213  // 221\n                                                                                                     // 214  // 222\n                    // No exception on NaN.                                                          // 215  // 223\n                    // 'new BigNumber() not a number: {n}'                                           // 216  // 224\n                    if ( str != 'NaN' ) ifExceptionsThrow( n, 3 );                                   // 217  // 225\n                    x['s'] = null;                                                                   // 218  // 226\n                }                                                                                    // 219  // 227\n                id = 0;                                                                              // 220  // 228\n                                                                                                     // 221  // 229\n                return;                                                                              // 222  // 230\n            }                                                                                        // 223  // 231\n        }                                                                                            // 224  // 232\n                                                                                                     // 225  // 233\n        // Decimal point?                                                                            // 226  // 234\n        if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );                           // 227  // 235\n                                                                                                     // 228  // 236\n        // Exponential form?                                                                         // 229  // 237\n        if ( ( i = str.search( /e/i ) ) > 0 ) {                                                      // 230  // 238\n                                                                                                     // 231  // 239\n            // Determine exponent.                                                                   // 232  // 240\n            if ( e < 0 ) e = i;                                                                      // 233  // 241\n            e += +str.slice( i + 1 );                                                                // 234  // 242\n            str = str.substring( 0, i );                                                             // 235  // 243\n        } else if ( e < 0 ) {                                                                        // 236  // 244\n                                                                                                     // 237  // 245\n            // Integer.                                                                              // 238  // 246\n            e = str.length;                                                                          // 239  // 247\n        }                                                                                            // 240  // 248\n                                                                                                     // 241  // 249\n        // Determine leading zeros.                                                                  // 242  // 250\n        for ( i = 0; str.charCodeAt(i) === 48; i++ );                                                // 243  // 251\n                                                                                                     // 244  // 252\n        // Determine trailing zeros.                                                                 // 245  // 253\n        for ( b = str.length; str.charCodeAt(--b) === 48; );                                         // 246  // 254\n        str = str.slice( i, b + 1 );                                                                 // 247  // 255\n                                                                                                     // 248  // 256\n        if (str) {                                                                                   // 249  // 257\n            b = str.length;                                                                          // 250  // 258\n                                                                                                     // 251  // 259\n            // Disallow numbers with over 15 significant digits if number type.                      // 252  // 260\n            // 'new BigNumber() number type has more than 15 significant digits: {n}'                // 253  // 261\n            if ( isNum && b > 15 ) ifExceptionsThrow( n, 0 );                                        // 254  // 262\n            e = e - i - 1;                                                                           // 255  // 263\n                                                                                                     // 256  // 264\n             // Overflow?                                                                            // 257  // 265\n            if ( e > MAX_EXP ) {                                                                     // 258  // 266\n                                                                                                     // 259  // 267\n                // Infinity.                                                                         // 260  // 268\n                x['c'] = x['e'] = null;                                                              // 261  // 269\n                                                                                                     // 262  // 270\n            // Underflow?                                                                            // 263  // 271\n            } else if ( e < MIN_EXP ) {                                                              // 264  // 272\n                                                                                                     // 265  // 273\n                // Zero.                                                                             // 266  // 274\n                x['c'] = [ x['e'] = 0 ];                                                             // 267  // 275\n            } else {                                                                                 // 268  // 276\n                x['e'] = e;                                                                          // 269  // 277\n                x['c'] = [];                                                                         // 270  // 278\n                                                                                                     // 271  // 279\n                // Transform base                                                                    // 272  // 280\n                                                                                                     // 273  // 281\n                // e is the base 10 exponent.                                                        // 274  // 282\n                // i is where to slice str to get the first element of the coefficient array.        // 275  // 283\n                i = ( e + 1 ) % LOG_BASE;                                                            // 276  // 284\n                if ( e < 0 ) i += LOG_BASE;                                                          // 277  // 285\n                                                                                                     // 278  // 286\n                // b is str.length.                                                                  // 279  // 287\n                if ( i < b ) {                                                                       // 280  // 288\n                    if (i) x['c'].push( +str.slice( 0, i ) );                                        // 281  // 289\n                    for ( b -= LOG_BASE; i < b; x['c'].push( +str.slice( i, i += LOG_BASE ) ) );     // 282  // 290\n                    str = str.slice(i);                                                              // 283  // 291\n                    i = LOG_BASE - str.length;                                                       // 284  // 292\n                } else {                                                                             // 285  // 293\n                    i -= b;                                                                          // 286  // 294\n                }                                                                                    // 287  // 295\n                                                                                                     // 288  // 296\n                for ( ; i--; str += '0' );                                                           // 289  // 297\n                x['c'].push( +str );                                                                 // 290  // 298\n            }                                                                                        // 291  // 299\n        } else {                                                                                     // 292  // 300\n                                                                                                     // 293  // 301\n            // Zero.                                                                                 // 294  // 302\n            x['c'] = [ x['e'] = 0 ];                                                                 // 295  // 303\n        }                                                                                            // 296  // 304\n        id = 0;                                                                                      // 297  // 305\n    }                                                                                                // 298  // 306\n                                                                                                     // 299  // 307\n                                                                                                     // 300  // 308\n    // CONSTRUCTOR PROPERTIES/METHODS                                                                // 301  // 309\n                                                                                                     // 302  // 310\n                                                                                                     // 303  // 311\n    BigNumber['ROUND_UP'] = 0;                                                                       // 304  // 312\n    BigNumber['ROUND_DOWN'] = 1;                                                                     // 305  // 313\n    BigNumber['ROUND_CEIL'] = 2;                                                                     // 306  // 314\n    BigNumber['ROUND_FLOOR'] = 3;                                                                    // 307  // 315\n    BigNumber['ROUND_HALF_UP'] = 4;                                                                  // 308  // 316\n    BigNumber['ROUND_HALF_DOWN'] = 5;                                                                // 309  // 317\n    BigNumber['ROUND_HALF_EVEN'] = 6;                                                                // 310  // 318\n    BigNumber['ROUND_HALF_CEIL'] = 7;                                                                // 311  // 319\n    BigNumber['ROUND_HALF_FLOOR'] = 8;                                                               // 312  // 320\n                                                                                                     // 313  // 321\n                                                                                                     // 314  // 322\n    /*                                                                                               // 315  // 323\n     * Configure infrequently-changing library-wide settings.                                        // 316  // 324\n     *                                                                                               // 317  // 325\n     * Accept an object or an argument list, with one or many of the following properties or         // 318  // 326\n     * parameters respectively:                                                                      // 319  // 327\n     * [ DECIMAL_PLACES [, ROUNDING_MODE [, EXPONENTIAL_AT [, RANGE [, ERRORS [, FORMAT ]]]]]]       // 320  // 328\n     *                                                                                               // 321  // 329\n     *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive.                                      // 322  // 330\n     *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive.                                        // 323  // 331\n     *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or                        // 324  // 332\n     *                                      [ integer -MAX to 0 incl., 0 to MAX incl. ].             // 325  // 333\n     *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or               // 326  // 334\n     *                                      [ integer -MAX to -1 incl., integer 1 to MAX incl. ].    // 327  // 335\n     *   ERRORS          {boolean|number}   true, false, 1 or 0.                                     // 328  // 336\n     *   FORMAT          {object}           See BigNumber.prototype.toFormat.                        // 329  // 337\n     *      decimalSeparator       {string}                                                          // 330  // 338\n     *      groupSeparator         {string}                                                          // 331  // 339\n     *      groupSize              {number}                                                          // 332  // 340\n     *      secondaryGroupSize     {number}                                                          // 333  // 341\n     *      fractionGroupSeparator {string}                                                          // 334  // 342\n     *      fractionGroupSize      {number}                                                          // 335  // 343\n     *                                                                                               // 336  // 344\n     * The validity of the values assigned to the above FORMAT object properties is not checked.     // 337  // 345\n     *                                                                                               // 338  // 346\n     * E.g.                                                                                          // 339  // 347\n     * BigNumber.config(20, 4) is equivalent to                                                      // 340  // 348\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })                                  // 341  // 349\n     *                                                                                               // 342  // 350\n     * Ignore properties/parameters set to null or undefined.                                        // 343  // 351\n     * Return an object with the properties current values.                                          // 344  // 352\n     */                                                                                              // 345  // 353\n    BigNumber['config'] = function () {                                                              // 346  // 354\n        var v, p,                                                                                    // 347  // 355\n            i = 0,                                                                                   // 348  // 356\n            r = {},                                                                                  // 349  // 357\n            a = arguments,                                                                           // 350  // 358\n            o = a[0],                                                                                // 351  // 359\n            c = 'config',                                                                            // 352  // 360\n            inRange = function ( n, lo, hi ) {                                                       // 353  // 361\n              return !( ( outOfRange = n < lo || n > hi ) || parse(n) != n && n !== 0 );             // 354  // 362\n            },                                                                                       // 355  // 363\n            has = o && typeof o == 'object'                                                          // 356  // 364\n              ? function () {if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null}                 // 357  // 365\n              : function () {if ( a.length > i ) return ( v = a[i++] ) != null};                     // 358  // 366\n                                                                                                     // 359  // 367\n        // [DECIMAL_PLACES] {number} Integer, 0 to MAX inclusive.                                    // 360  // 368\n        if ( has( p = 'DECIMAL_PLACES' ) ) {                                                         // 361  // 369\n                                                                                                     // 362  // 370\n            if ( inRange( v, 0, MAX ) ) {                                                            // 363  // 371\n                DECIMAL_PLACES = v | 0;                                                              // 364  // 372\n            } else {                                                                                 // 365  // 373\n                                                                                                     // 366  // 374\n                // 'config() DECIMAL_PLACES not an integer: {v}'                                     // 367  // 375\n                // 'config() DECIMAL_PLACES out of range: {v}'                                       // 368  // 376\n                ifExceptionsThrow( v, p, c );                                                        // 369  // 377\n            }                                                                                        // 370  // 378\n        }                                                                                            // 371  // 379\n        r[p] = DECIMAL_PLACES;                                                                       // 372  // 380\n                                                                                                     // 373  // 381\n        // [ROUNDING_MODE] {number} Integer, 0 to 8 inclusive.                                       // 374  // 382\n        if ( has( p = 'ROUNDING_MODE' ) ) {                                                          // 375  // 383\n                                                                                                     // 376  // 384\n            if ( inRange( v, 0, 8 ) ) {                                                              // 377  // 385\n                ROUNDING_MODE = v | 0;                                                               // 378  // 386\n            } else {                                                                                 // 379  // 387\n                                                                                                     // 380  // 388\n                // 'config() ROUNDING_MODE not an integer: {v}'                                      // 381  // 389\n                // 'config() ROUNDING_MODE out of range: {v}'                                        // 382  // 390\n                ifExceptionsThrow( v, p, c );                                                        // 383  // 391\n            }                                                                                        // 384  // 392\n        }                                                                                            // 385  // 393\n        r[p] = ROUNDING_MODE;                                                                        // 386  // 394\n                                                                                                     // 387  // 395\n        // [EXPONENTIAL_AT] {number|number[]}                                                        // 388  // 396\n        // Integer, -MAX to MAX inclusive or [ integer -MAX to 0 inclusive, 0 to MAX inclusive ].    // 389  // 397\n        if ( has( p = 'EXPONENTIAL_AT' ) ) {                                                         // 390  // 398\n                                                                                                     // 391  // 399\n            if ( inRange( v, -MAX, MAX ) ) {                                                         // 392  // 400\n                TO_EXP_NEG = -( TO_EXP_POS = ~~( v < 0 ? -v : +v ) );                                // 393  // 401\n            } else if ( !outOfRange && v && inRange( v[0], -MAX, 0 ) && inRange( v[1], 0, MAX ) ) {  // 394  // 402\n                TO_EXP_NEG = ~~v[0];                                                                 // 395  // 403\n                TO_EXP_POS = ~~v[1];                                                                 // 396  // 404\n            } else {                                                                                 // 397  // 405\n                                                                                                     // 398  // 406\n                // 'config() EXPONENTIAL_AT not an integer or not [integer, integer]: {v}'           // 399  // 407\n                // 'config() EXPONENTIAL_AT out of range or not [negative, positive: {v}'            // 400  // 408\n                ifExceptionsThrow( v, p, c, 1 );                                                     // 401  // 409\n            }                                                                                        // 402  // 410\n        }                                                                                            // 403  // 411\n        r[p] = [ TO_EXP_NEG, TO_EXP_POS ];                                                           // 404  // 412\n                                                                                                     // 405  // 413\n        // [RANGE][ {number|number[]} Non-zero integer, -MAX to MAX inclusive or                     // 406  // 414\n        // [ integer -MAX to -1 inclusive, integer 1 to MAX inclusive ].                             // 407  // 415\n        if ( has( p = 'RANGE' ) ) {                                                                  // 408  // 416\n                                                                                                     // 409  // 417\n            if ( inRange( v, -MAX, MAX ) && ~~v ) {                                                  // 410  // 418\n                MIN_EXP = -( MAX_EXP = ~~( v < 0 ? -v : +v ) );                                      // 411  // 419\n            } else if ( !outOfRange && v && inRange( v[0], -MAX, -1 ) && inRange( v[1], 1, MAX ) ) { // 412  // 420\n                MIN_EXP = ~~v[0];                                                                    // 413  // 421\n                MAX_EXP = ~~v[1];                                                                    // 414  // 422\n            } else {                                                                                 // 415  // 423\n                                                                                                     // 416  // 424\n                // 'config() RANGE not a non-zero integer or not [integer, integer]: {v}'            // 417  // 425\n                // 'config() RANGE out of range or not [negative, positive: {v}'                     // 418  // 426\n                ifExceptionsThrow( v, p, c, 1, 1 );                                                  // 419  // 427\n            }                                                                                        // 420  // 428\n        }                                                                                            // 421  // 429\n        r[p] = [ MIN_EXP, MAX_EXP ];                                                                 // 422  // 430\n                                                                                                     // 423  // 431\n        // [ERRORS] {boolean|number} true, false, 1 or 0.                                            // 424  // 432\n        if ( has( p = 'ERRORS' ) ) {                                                                 // 425  // 433\n                                                                                                     // 426  // 434\n            if ( v === !!v || v === 1 || v === 0 ) {                                                 // 427  // 435\n                outOfRange = id = 0;                                                                 // 428  // 436\n                parse = ( ERRORS = !!v ) ? parseInt : parseFloat;                                    // 429  // 437\n            } else {                                                                                 // 430  // 438\n                                                                                                     // 431  // 439\n                // 'config() ERRORS not a boolean or binary digit: {v}'                              // 432  // 440\n                ifExceptionsThrow( v, p, c, 0, 0, 1 );                                               // 433  // 441\n            }                                                                                        // 434  // 442\n        }                                                                                            // 435  // 443\n        r[p] = ERRORS;                                                                               // 436  // 444\n                                                                                                     // 437  // 445\n        // [FORMAT] {object}                                                                         // 438  // 446\n        if ( has( p = 'FORMAT' ) ) {                                                                 // 439  // 447\n                                                                                                     // 440  // 448\n            if ( typeof v == 'object' ) {                                                            // 441  // 449\n                FORMAT = v;                                                                          // 442  // 450\n            } else if (ERRORS) {                                                                     // 443  // 451\n                                                                                                     // 444  // 452\n                // 'config() FORMAT not an object: {v}'                                              // 445  // 453\n                r = new Error( c + '() ' + p + ' not an object: ' + v );                             // 446  // 454\n                r['name'] = 'BigNumber Error';                                                       // 447  // 455\n                throw r;                                                                             // 448  // 456\n            }                                                                                        // 449  // 457\n        }                                                                                            // 450  // 458\n        r[p] = FORMAT;                                                                               // 451  // 459\n                                                                                                     // 452  // 460\n        return r;                                                                                    // 453  // 461\n    };                                                                                               // 454  // 462\n                                                                                                     // 455  // 463\n                                                                                                     // 456  // 464\n    // PRIVATE FUNCTIONS                                                                             // 457  // 465\n                                                                                                     // 458  // 466\n                                                                                                     // 459  // 467\n    /*                                                                                               // 460  // 468\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.       // 461  // 469\n     * Called by minus, plus and times.                                                              // 462  // 470\n     */                                                                                              // 463  // 471\n    function normalise( bn, c, e ) {                                                                 // 464  // 472\n        var i = 1,                                                                                   // 465  // 473\n            j = c.length;                                                                            // 466  // 474\n                                                                                                     // 467  // 475\n         // Remove trailing zeros.                                                                   // 468  // 476\n        for ( ; !c[--j]; c.pop() );                                                                  // 469  // 477\n                                                                                                     // 470  // 478\n        // Calculate the base 10 exponent. First get the number of digits of c[0].                   // 471  // 479\n        for ( j = c[0]; j >= 10; j /= 10, i++ );                                                     // 472  // 480\n                                                                                                     // 473  // 481\n        // Overflow?                                                                                 // 474  // 482\n        if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {                                              // 475  // 483\n                                                                                                     // 476  // 484\n            // Infinity.                                                                             // 477  // 485\n            bn['c'] = bn['e'] = null;                                                                // 478  // 486\n                                                                                                     // 479  // 487\n        // Underflow?                                                                                // 480  // 488\n        } else if ( e < MIN_EXP ) {                                                                  // 481  // 489\n                                                                                                     // 482  // 490\n            // Zero.                                                                                 // 483  // 491\n            bn['c'] = [ bn['e'] = 0 ];                                                               // 484  // 492\n        } else {                                                                                     // 485  // 493\n            bn['e'] = e;                                                                             // 486  // 494\n            bn['c'] = c;                                                                             // 487  // 495\n        }                                                                                            // 488  // 496\n                                                                                                     // 489  // 497\n        return bn;                                                                                   // 490  // 498\n    }                                                                                                // 491  // 499\n                                                                                                     // 492  // 500\n                                                                                                     // 493  // 501\n    /*                                                                                               // 494  // 502\n     * Returns the coefficient array as a string of base 10 digits.                                  // 495  // 503\n     */                                                                                              // 496  // 504\n    function coefficientToString(a) {                                                                // 497  // 505\n        var s, z,                                                                                    // 498  // 506\n            i = 1,                                                                                   // 499  // 507\n            j = a.length,                                                                            // 500  // 508\n            r = a[0] + '';                                                                           // 501  // 509\n                                                                                                     // 502  // 510\n        for ( ; i < j; ) {                                                                           // 503  // 511\n            s = a[i++] + '';                                                                         // 504  // 512\n            z = LOG_BASE - s.length;                                                                 // 505  // 513\n            for ( ; z--; s = '0' + s );                                                              // 506  // 514\n            r += s;                                                                                  // 507  // 515\n        }                                                                                            // 508  // 516\n                                                                                                     // 509  // 517\n        // '0'                                                                                       // 510  // 518\n        for ( j = r.length; r.charCodeAt(--j) === 48; );                                             // 511  // 519\n                                                                                                     // 512  // 520\n        return r.slice( 0, j + 1 || 1 );                                                             // 513  // 521\n    }                                                                                                // 514  // 522\n                                                                                                     // 515  // 523\n                                                                                                     // 516  // 524\n    /*                                                                                               // 517  // 525\n     * Convert string of baseIn to an array of numbers of baseOut.                                   // 518  // 526\n     * Eg. convertBase('255', 10, 16) returns [15, 15].                                              // 519  // 527\n     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].                                              // 520  // 528\n     */                                                                                              // 521  // 529\n    function toBaseOut( str, baseIn, baseOut ) {                                                     // 522  // 530\n        var j,                                                                                       // 523  // 531\n            arr = [0],                                                                               // 524  // 532\n            arrL,                                                                                    // 525  // 533\n            i = 0,                                                                                   // 526  // 534\n            strL = str.length;                                                                       // 527  // 535\n                                                                                                     // 528  // 536\n        for ( ; i < strL; ) {                                                                        // 529  // 537\n            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );                                  // 530  // 538\n            arr[ j = 0 ] += DIGITS.indexOf( str.charAt( i++ ) );                                     // 531  // 539\n                                                                                                     // 532  // 540\n            for ( ; j < arr.length; j++ ) {                                                          // 533  // 541\n                                                                                                     // 534  // 542\n                if ( arr[j] > baseOut - 1 ) {                                                        // 535  // 543\n                    if ( arr[j + 1] == null ) arr[j + 1] = 0;                                        // 536  // 544\n                    arr[j + 1] += arr[j] / baseOut | 0;                                              // 537  // 545\n                    arr[j] %= baseOut;                                                               // 538  // 546\n                }                                                                                    // 539  // 547\n            }                                                                                        // 540  // 548\n        }                                                                                            // 541  // 549\n                                                                                                     // 542  // 550\n        return arr.reverse();                                                                        // 543  // 551\n    }                                                                                                // 544  // 552\n                                                                                                     // 545  // 553\n    /*                                                                                               // 546  // 554\n     * Convert a numeric string of baseIn to a numeric string of baseOut.                            // 547  // 555\n     */                                                                                              // 548  // 556\n    function convertBase( str, baseOut, baseIn, sign ) {                                             // 549  // 557\n        var d, e, j, r, x, xc, y,                                                                    // 550  // 558\n            i = str.indexOf( '.' ),                                                                  // 551  // 559\n            rm = ROUNDING_MODE;                                                                      // 552  // 560\n                                                                                                     // 553  // 561\n        if ( baseIn < 37 ) str = str.toLowerCase();                                                  // 554  // 562\n                                                                                                     // 555  // 563\n        // Non-integer.                                                                              // 556  // 564\n        if ( i >= 0 ) {                                                                              // 557  // 565\n            str = str.replace( '.', '' );                                                            // 558  // 566\n            y = new BigNumber(baseIn);                                                               // 559  // 567\n            x = y['pow']( str.length - i );                                                          // 560  // 568\n                                                                                                     // 561  // 569\n            // Convert str as if an integer, then restore the fraction part by dividing the result   // 562  // 570\n            // by its base raised to a power. Use toFixed to avoid possible exponential notation.    // 563  // 571\n            y['c'] = toBaseOut( x.toFixed(), 10, baseOut );                                          // 564  // 572\n            y['e'] = y['c'].length;                                                                  // 565  // 573\n        }                                                                                            // 566  // 574\n                                                                                                     // 567  // 575\n        // Convert the number as integer.                                                            // 568  // 576\n        xc = toBaseOut( str, baseIn, baseOut );                                                      // 569  // 577\n        e = j = xc.length;                                                                           // 570  // 578\n                                                                                                     // 571  // 579\n        // Remove trailing zeros.                                                                    // 572  // 580\n        for ( ; xc[--j] == 0; xc.pop() );                                                            // 573  // 581\n        if ( !xc[0] ) return '0';                                                                    // 574  // 582\n                                                                                                     // 575  // 583\n        if ( i < 0 ) {                                                                               // 576  // 584\n            --e;                                                                                     // 577  // 585\n        } else {                                                                                     // 578  // 586\n            x['c'] = xc;                                                                             // 579  // 587\n            x['e'] = e;                                                                              // 580  // 588\n            // sign is needed for correct rounding.                                                  // 581  // 589\n            x['s'] = sign;                                                                           // 582  // 590\n            x = div( x, y, DECIMAL_PLACES, rm, baseOut );                                            // 583  // 591\n            xc = x['c'];                                                                             // 584  // 592\n            r = x['r'];                                                                              // 585  // 593\n            e = x['e'];                                                                              // 586  // 594\n        }                                                                                            // 587  // 595\n        d = e + DECIMAL_PLACES + 1;                                                                  // 588  // 596\n                                                                                                     // 589  // 597\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.                // 590  // 598\n        i = xc[d];                                                                                   // 591  // 599\n        j = baseOut / 2;                                                                             // 592  // 600\n        r = r || d < 0 || xc[d + 1] != null;                                                         // 593  // 601\n                                                                                                     // 594  // 602\n        r = rm < 4                                                                                   // 595  // 603\n          ? ( i != null || r ) && ( rm == 0 || rm == ( x['s'] < 0 ? 3 : 2 ) )                        // 596  // 604\n          : i > j || i == j &&                                                                       // 597  // 605\n            ( rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == ( x['s'] < 0 ? 8 : 7 ) );            // 598  // 606\n                                                                                                     // 599  // 607\n        if ( d < 1 || !xc[0] ) {                                                                     // 600  // 608\n            xc.length = 1;                                                                           // 601  // 609\n            j = 0;                                                                                   // 602  // 610\n                                                                                                     // 603  // 611\n            if (r) {                                                                                 // 604  // 612\n                                                                                                     // 605  // 613\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.                                                  // 606  // 614\n                xc[0] = 1;                                                                           // 607  // 615\n                e = -DECIMAL_PLACES;                                                                 // 608  // 616\n            } else {                                                                                 // 609  // 617\n                                                                                                     // 610  // 618\n                // Zero.                                                                             // 611  // 619\n                e = xc[0] = 0;                                                                       // 612  // 620\n            }                                                                                        // 613  // 621\n        } else {                                                                                     // 614  // 622\n            xc.length = d;                                                                           // 615  // 623\n                                                                                                     // 616  // 624\n            if (r) {                                                                                 // 617  // 625\n                                                                                                     // 618  // 626\n                // Rounding up may mean the previous digit has to be rounded up and so on.           // 619  // 627\n                for ( --baseOut; ++xc[--d] > baseOut; ) {                                            // 620  // 628\n                    xc[d] = 0;                                                                       // 621  // 629\n                                                                                                     // 622  // 630\n                    if ( !d ) {                                                                      // 623  // 631\n                        ++e;                                                                         // 624  // 632\n                        xc.unshift(1);                                                               // 625  // 633\n                    }                                                                                // 626  // 634\n                }                                                                                    // 627  // 635\n            }                                                                                        // 628  // 636\n                                                                                                     // 629  // 637\n            // Determine trailing zeros.                                                             // 630  // 638\n            for ( j = xc.length; !xc[--j]; );                                                        // 631  // 639\n        }                                                                                            // 632  // 640\n                                                                                                     // 633  // 641\n        // E.g. [4, 11, 15] becomes 4bf.                                                             // 634  // 642\n        for ( i = 0, str = ''; i <= j; str += DIGITS.charAt( xc[i++] ) );                            // 635  // 643\n                                                                                                     // 636  // 644\n        // Negative exponent?                                                                        // 637  // 645\n        if ( e < 0 ) {                                                                               // 638  // 646\n                                                                                                     // 639  // 647\n            // Prepend zeros.                                                                        // 640  // 648\n            for ( ; ++e; str = '0' + str );                                                          // 641  // 649\n            str = '0.' + str;                                                                        // 642  // 650\n                                                                                                     // 643  // 651\n        // Positive exponent?                                                                        // 644  // 652\n        } else {                                                                                     // 645  // 653\n            i = str.length;                                                                          // 646  // 654\n                                                                                                     // 647  // 655\n            // Append zeros.                                                                         // 648  // 656\n            if ( ++e > i ) {                                                                         // 649  // 657\n                for ( e -= i; e-- ; str += '0' );                                                    // 650  // 658\n            } else if ( e < i ) {                                                                    // 651  // 659\n                str = str.slice( 0, e ) + '.' + str.slice(e);                                        // 652  // 660\n            }                                                                                        // 653  // 661\n        }                                                                                            // 654  // 662\n                                                                                                     // 655  // 663\n        // No negative numbers: the caller will add the sign.                                        // 656  // 664\n        return str;                                                                                  // 657  // 665\n    }                                                                                                // 658  // 666\n                                                                                                     // 659  // 667\n                                                                                                     // 660  // 668\n    /*                                                                                               // 661  // 669\n     * Perform division in the specified base. Called by div and convertBase.                        // 662  // 670\n     */                                                                                              // 663  // 671\n    var div = ( function () {                                                                        // 664  // 672\n                                                                                                     // 665  // 673\n        // Assumes non-zero x and k.                                                                 // 666  // 674\n        function multiply( x, k, base ) {                                                            // 667  // 675\n            var m, temp, xlo, xhi,                                                                   // 668  // 676\n                carry = 0,                                                                           // 669  // 677\n                i = x.length,                                                                        // 670  // 678\n                klo = k % SQRT_BASE,                                                                 // 671  // 679\n                khi = k / SQRT_BASE | 0;                                                             // 672  // 680\n                                                                                                     // 673  // 681\n            for ( x = x.slice(); i--; ) {                                                            // 674  // 682\n                xlo = x[i] % SQRT_BASE;                                                              // 675  // 683\n                xhi = x[i] / SQRT_BASE | 0;                                                          // 676  // 684\n                m = khi * xlo + xhi * klo;                                                           // 677  // 685\n                temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;                        // 678  // 686\n                carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;                     // 679  // 687\n                x[i] = temp % base;                                                                  // 680  // 688\n            }                                                                                        // 681  // 689\n            if (carry) x.unshift(carry);                                                             // 682  // 690\n                                                                                                     // 683  // 691\n            return x;                                                                                // 684  // 692\n        }                                                                                            // 685  // 693\n                                                                                                     // 686  // 694\n        function compare( a, b, aL, bL ) {                                                           // 687  // 695\n            var i, cmp;                                                                              // 688  // 696\n                                                                                                     // 689  // 697\n            if ( aL != bL ) {                                                                        // 690  // 698\n                cmp = aL > bL ? 1 : -1;                                                              // 691  // 699\n            } else {                                                                                 // 692  // 700\n                                                                                                     // 693  // 701\n                for ( i = cmp = 0; i < aL; i++ ) {                                                   // 694  // 702\n                                                                                                     // 695  // 703\n                    if ( a[i] != b[i] ) {                                                            // 696  // 704\n                        cmp = a[i] > b[i] ? 1 : -1;                                                  // 697  // 705\n                        break;                                                                       // 698  // 706\n                    }                                                                                // 699  // 707\n                }                                                                                    // 700  // 708\n            }                                                                                        // 701  // 709\n            return cmp;                                                                              // 702  // 710\n        }                                                                                            // 703  // 711\n                                                                                                     // 704  // 712\n        function subtract( a, b, aL, base ) {                                                        // 705  // 713\n            var i = 0;                                                                               // 706  // 714\n                                                                                                     // 707  // 715\n            // Subtract b from a.                                                                    // 708  // 716\n            for ( ; aL--; ) {                                                                        // 709  // 717\n                a[aL] -= i;                                                                          // 710  // 718\n                i = a[aL] < b[aL] ? 1 : 0;                                                           // 711  // 719\n                a[aL] = i * base + a[aL] - b[aL];                                                    // 712  // 720\n            }                                                                                        // 713  // 721\n                                                                                                     // 714  // 722\n            // Remove leading zeros.                                                                 // 715  // 723\n            for ( ; !a[0] && a.length > 1; a.shift() );                                              // 716  // 724\n        }                                                                                            // 717  // 725\n                                                                                                     // 718  // 726\n        // x: dividend, y: divisor.                                                                  // 719  // 727\n        return function ( x, y, dp, rm, base ) {                                                     // 720  // 728\n            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,                // 721  // 729\n                yL, yz,                                                                              // 722  // 730\n                s = x['s'] == y['s'] ? 1 : -1,                                                       // 723  // 731\n                xc = x['c'],                                                                         // 724  // 732\n                yc = y['c'];                                                                         // 725  // 733\n                                                                                                     // 726  // 734\n            // Either NaN, Infinity or 0?                                                            // 727  // 735\n            if ( !xc || !xc[0] || !yc || !yc[0] ) {                                                  // 728  // 736\n                                                                                                     // 729  // 737\n                return new BigNumber(                                                                // 730  // 738\n                                                                                                     // 731  // 739\n                  // Return NaN if either NaN, or both Infinity or 0.                                // 732  // 740\n                  !x['s'] || !y['s'] || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :                  // 733  // 741\n                                                                                                     // 734  // 742\n                    // Return +-0 if x is 0 or y is +-Infinity, or return +-Infinity as y is 0.      // 735  // 743\n                    xc && xc[0] == 0 || !yc ? s * 0 : s / 0                                          // 736  // 744\n                );                                                                                   // 737  // 745\n            }                                                                                        // 738  // 746\n                                                                                                     // 739  // 747\n            q = new BigNumber(s);                                                                    // 740  // 748\n            qc = q['c'] = [];                                                                        // 741  // 749\n            e = x['e'] - y['e'];                                                                     // 742  // 750\n            s = dp + e + 1;                                                                          // 743  // 751\n                                                                                                     // 744  // 752\n            if ( !base ) {                                                                           // 745  // 753\n                base = BASE;                                                                         // 746  // 754\n                                                                                                     // 747  // 755\n                //e = mathfloor( x['e'] / LOG_BASE ) - mathfloor( y['e'] / LOG_BASE );               // 748  // 756\n                e = ( xL = x['e'] / LOG_BASE, i = xL | 0, xL > 0 || xL === i ? i : i - 1 ) -         // 749  // 757\n                    ( yL = y['e'] / LOG_BASE, i = yL | 0, yL > 0 || yL === i ? i : i - 1 );          // 750  // 758\n                                                                                                     // 751  // 759\n                s = s / LOG_BASE | 0;                                                                // 752  // 760\n            }                                                                                        // 753  // 761\n                                                                                                     // 754  // 762\n            // Result exponent may be one less then the current value of e.                          // 755  // 763\n            // The coefficients of the BigNumbers from convertBase may have trailing zeros.          // 756  // 764\n            for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );                                             // 757  // 765\n            if ( yc[i] > ( xc[i] || 0 ) ) e--;                                                       // 758  // 766\n                                                                                                     // 759  // 767\n            if ( s < 0 ) {                                                                           // 760  // 768\n                qc.push(1);                                                                          // 761  // 769\n                more = true;                                                                         // 762  // 770\n            } else {                                                                                 // 763  // 771\n                xL = xc.length;                                                                      // 764  // 772\n                yL = yc.length;                                                                      // 765  // 773\n                i = 0;                                                                               // 766  // 774\n                s += 2;                                                                              // 767  // 775\n                                                                                                     // 768  // 776\n                /*                                                                                   // 769  // 777\n                // TODO: fast path division when divisor < base                                      // 770  // 778\n                if ( yL == 1 ) {                                                                     // 771  // 779\n                    n = 0;                                                                           // 772  // 780\n                    yc = yc[0];                                                                      // 773  // 781\n                    s++;                                                                             // 774  // 782\n                    // n is the carry.                                                               // 775  // 783\n                    for ( ; ( i < xL || n ) && s--; i++ ) {                                          // 776  // 784\n                        // Can't use this, it will overflow 2^53.                                    // 777  // 785\n                        var t = n * base + ( xc[i] || 0 );                                           // 778  // 786\n                        qc[i] = mathfloor( t / yc );                                                 // 779  // 787\n                        n = t % yc;                                                                  // 780  // 788\n                    }                                                                                // 781  // 789\n                    more = n || i < xL;                                                              // 782  // 790\n                                                                                                     // 783  // 791\n                // divisor >= base                                                                   // 784  // 792\n                } else {                                                                             // 785  // 793\n                */                                                                                   // 786  // 794\n                    // Normalise xc and yc so highest order digit of yc is >= base/2                 // 787  // 795\n                                                                                                     // 788  // 796\n                    n = mathfloor( base / ( yc[0] + 1 ) );                                           // 789  // 797\n                                                                                                     // 790  // 798\n                    if ( n > 1 ) {                                                                   // 791  // 799\n                        yc = multiply( yc, n, base );                                                // 792  // 800\n                        xc = multiply( xc, n, base );                                                // 793  // 801\n                        yL = yc.length;                                                              // 794  // 802\n                        xL = xc.length;                                                              // 795  // 803\n                    }                                                                                // 796  // 804\n                                                                                                     // 797  // 805\n                    xi = yL;                                                                         // 798  // 806\n                    rem = xc.slice( 0, yL );                                                         // 799  // 807\n                    remL = rem.length;                                                               // 800  // 808\n                                                                                                     // 801  // 809\n                    // Add zeros to make remainder as long as divisor.                               // 802  // 810\n                    for ( ; remL < yL; rem[remL++] = 0 );                                            // 803  // 811\n                    yz = yc.slice();                                                                 // 804  // 812\n                    yz.unshift(0);                                                                   // 805  // 813\n                    yc0 = yc[0];                                                                     // 806  // 814\n                    if ( yc[1] >= base / 2 ) yc0++;                                                  // 807  // 815\n                                                                                                     // 808  // 816\n                    do {                                                                             // 809  // 817\n                        n = 0;                                                                       // 810  // 818\n                                                                                                     // 811  // 819\n                        // Compare divisor and remainder.                                            // 812  // 820\n                        cmp = compare( yc, rem, yL, remL );                                          // 813  // 821\n                                                                                                     // 814  // 822\n                        // If divisor < remainder.                                                   // 815  // 823\n                        if ( cmp < 0 ) {                                                             // 816  // 824\n                                                                                                     // 817  // 825\n                            // Calculate trial digit, n.                                             // 818  // 826\n                                                                                                     // 819  // 827\n                            rem0 = rem[0];                                                           // 820  // 828\n                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );                  // 821  // 829\n                                                                                                     // 822  // 830\n                            // n is how many times the divisor goes into the current remainder.      // 823  // 831\n                            n = mathfloor( rem0 / yc0 );                                             // 824  // 832\n                                                                                                     // 825  // 833\n                                                                                                     // 826  // 834\n                            //  Algorithm:                                                           // 827  // 835\n                            //  1. product = divisor * trial digit (n)                               // 828  // 836\n                            //  2. if product > remainder: product -= divisor, n--                   // 829  // 837\n                            //  3. remainder -= product                                              // 830  // 838\n                            //  4. if product was < remainder at 2:                                  // 831  // 839\n                            //    5. compare new remainder and divisor                               // 832  // 840\n                            //    6. If remainder > divisor: remainder -= divisor, n++               // 833  // 841\n                                                                                                     // 834  // 842\n                            if ( n > 1 ) {                                                           // 835  // 843\n                                if ( n >= base ) n = base - 1;                                       // 836  // 844\n                                                                                                     // 837  // 845\n                                // product = divisor * trial digit.                                  // 838  // 846\n                                prod = multiply( yc, n, base );                                      // 839  // 847\n                                prodL = prod.length;                                                 // 840  // 848\n                                remL = rem.length;                                                   // 841  // 849\n                                                                                                     // 842  // 850\n                                // Compare product and remainder.                                    // 843  // 851\n                                cmp = compare( prod, rem, prodL, remL );                             // 844  // 852\n                                                                                                     // 845  // 853\n                                // product > remainder.                                              // 846  // 854\n                                if ( cmp == 1 ) {                                                    // 847  // 855\n                                    n--;                                                             // 848  // 856\n                                                                                                     // 849  // 857\n                                    // Subtract divisor from product.                                // 850  // 858\n                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );             // 851  // 859\n                                }                                                                    // 852  // 860\n                            } else {                                                                 // 853  // 861\n                                                                                                     // 854  // 862\n                                // cmp is -1.                                                        // 855  // 863\n                                // If n is 0, there is no need to compare yc and rem again below,    // 856  // 864\n                                // so change cmp to 1 to avoid it.                                   // 857  // 865\n                                // If n is 1, compare yc and rem again below.                        // 858  // 866\n                                if ( n == 0 ) cmp = n = 1;                                           // 859  // 867\n                                prod = yc.slice();                                                   // 860  // 868\n                            }                                                                        // 861  // 869\n                                                                                                     // 862  // 870\n                            prodL = prod.length;                                                     // 863  // 871\n                            if ( prodL < remL ) prod.unshift(0);                                     // 864  // 872\n                                                                                                     // 865  // 873\n                            // Subtract product from remainder.                                      // 866  // 874\n                            subtract( rem, prod, remL, base );                                       // 867  // 875\n                                                                                                     // 868  // 876\n                            // If product was < previous remainder.                                  // 869  // 877\n                            if ( cmp == -1 ) {                                                       // 870  // 878\n                                remL = rem.length;                                                   // 871  // 879\n                                                                                                     // 872  // 880\n                                // Compare divisor and new remainder.                                // 873  // 881\n                                cmp = compare( yc, rem, yL, remL );                                  // 874  // 882\n                                                                                                     // 875  // 883\n                                // If divisor < new remainder, subtract divisor from remainder.      // 876  // 884\n                                if ( cmp < 1 ) {                                                     // 877  // 885\n                                    n++;                                                             // 878  // 886\n                                                                                                     // 879  // 887\n                                    // Subtract divisor from remainder.                              // 880  // 888\n                                    subtract( rem, yL < remL ? yz : yc, remL, base );                // 881  // 889\n                                }                                                                    // 882  // 890\n                            }                                                                        // 883  // 891\n                            remL = rem.length;                                                       // 884  // 892\n                        } else if ( cmp === 0 ) {                                                    // 885  // 893\n                            n++;                                                                     // 886  // 894\n                            rem = [0];                                                               // 887  // 895\n                        }    // if cmp === 1, n will be 0                                            // 888  // 896\n                                                                                                     // 889  // 897\n                        // Add the next digit, n, to the result array.                               // 890  // 898\n                        qc[i++] = n;                                                                 // 891  // 899\n                                                                                                     // 892  // 900\n                        // Update the remainder.                                                     // 893  // 901\n                        if ( cmp && rem[0] ) {                                                       // 894  // 902\n                            rem[remL++] = xc[xi] || 0;                                               // 895  // 903\n                        } else {                                                                     // 896  // 904\n                            rem = [ xc[xi] ];                                                        // 897  // 905\n                            remL = 1;                                                                // 898  // 906\n                        }                                                                            // 899  // 907\n                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );                              // 900  // 908\n                                                                                                     // 901  // 909\n                    more = rem[0] != null;                                                           // 902  // 910\n                //}                                                                                  // 903  // 911\n                                                                                                     // 904  // 912\n                // Leading zero?                                                                     // 905  // 913\n                if ( !qc[0] ) qc.shift();                                                            // 906  // 914\n            }                                                                                        // 907  // 915\n                                                                                                     // 908  // 916\n            if ( base == BASE ) {                                                                    // 909  // 917\n                                                                                                     // 910  // 918\n                // To calculate q.e, first get the number of digits of qc[0].                        // 911  // 919\n                for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );                                     // 912  // 920\n                rnd( q, dp + ( q['e'] = i + e * LOG_BASE - 1 ) + 1, rm, more );                      // 913  // 921\n                                                                                                     // 914  // 922\n            // div is being used for base conversion.                                                // 915  // 923\n            } else {                                                                                 // 916  // 924\n                q['e'] = e;                                                                          // 917  // 925\n                q['r'] = +more;                                                                      // 918  // 926\n            }                                                                                        // 919  // 927\n            return q;                                                                                // 920  // 928\n        };                                                                                           // 921  // 929\n    })();                                                                                            // 922  // 930\n                                                                                                     // 923  // 931\n                                                                                                     // 924  // 932\n    /*                                                                                               // 925  // 933\n     * Return a string representing the value of BigNumber n in normal or exponential notation       // 926  // 934\n     * rounded to the specified decimal places or significant digits.                                // 927  // 935\n     *                                                                                               // 928  // 936\n     * Called by toString (k: 1), toExponential (k: 1), toFixed (k: undefined), toPrecision (k: 2).  // 929  // 937\n     * i is the index (with the value in normal notation) of the digit that may be rounded up.       // 930  // 938\n     * d is the number of digits required including fraction-part trailing zeros.                    // 931  // 939\n     * z is the number of zeros to be appended.                                                      // 932  // 940\n     */                                                                                              // 933  // 941\n    function format( n, i, k ) {                                                                     // 934  // 942\n        var d, str, z,                                                                               // 935  // 943\n            e = ( n = new BigNumber(n) )['e'];                                                       // 936  // 944\n                                                                                                     // 937  // 945\n        // i == null when toExponential(no arg), or toString() when x >= toExpPos etc.               // 938  // 946\n        if ( i == null ) {                                                                           // 939  // 947\n            d = 0;                                                                                   // 940  // 948\n        } else {                                                                                     // 941  // 949\n            rnd( n, ++i, ROUNDING_MODE );                                                            // 942  // 950\n                                                                                                     // 943  // 951\n            // n['e'] may have changed if the value was rounded up.                                  // 944  // 952\n            d = k ? i : i + n['e'] - e;                                                              // 945  // 953\n            e = n['e'];                                                                              // 946  // 954\n        }                                                                                            // 947  // 955\n        str = coefficientToString( n['c'] );                                                         // 948  // 956\n                                                                                                     // 949  // 957\n        // toPrecision returns exponential notation if the number of significant digits specified    // 950  // 958\n        // is less than the number of digits necessary to represent the integer part of the value    // 951  // 959\n        // in normal notation.                                                                       // 952  // 960\n                                                                                                     // 953  // 961\n        // Exponential notation.                                                                     // 954  // 962\n        if ( k == 1 || k == 2 && ( i <= e || e <= TO_EXP_NEG ) ) {                                   // 955  // 963\n                                                                                                     // 956  // 964\n            // Append zeros?                                                                         // 957  // 965\n            for ( ; str.length < d; str += '0' );                                                    // 958  // 966\n            if ( str.length > 1 ) str = str.charAt(0) + '.' + str.slice(1);                          // 959  // 967\n            str += ( e < 0 ? 'e' : 'e+' ) + e;                                                       // 960  // 968\n                                                                                                     // 961  // 969\n        // Fixed point notation.                                                                     // 962  // 970\n        } else {                                                                                     // 963  // 971\n            k = str.length;                                                                          // 964  // 972\n                                                                                                     // 965  // 973\n            // Negative exponent?                                                                    // 966  // 974\n            if ( e < 0 ) {                                                                           // 967  // 975\n                z = d - k;                                                                           // 968  // 976\n                                                                                                     // 969  // 977\n                // Prepend zeros.                                                                    // 970  // 978\n                for ( ; ++e; str = '0' + str );                                                      // 971  // 979\n                str = '0.' + str;                                                                    // 972  // 980\n                                                                                                     // 973  // 981\n            // Positive exponent?                                                                    // 974  // 982\n            } else {                                                                                 // 975  // 983\n                                                                                                     // 976  // 984\n                if ( ++e > k ) {                                                                     // 977  // 985\n                    z = d - e;                                                                       // 978  // 986\n                                                                                                     // 979  // 987\n                    // Append zeros.                                                                 // 980  // 988\n                    for ( e -= k; e-- ; str += '0' );                                                // 981  // 989\n                    if ( z > 0 ) str += '.';                                                         // 982  // 990\n                } else {                                                                             // 983  // 991\n                    z = d - k;                                                                       // 984  // 992\n                                                                                                     // 985  // 993\n                    if ( e < k ) {                                                                   // 986  // 994\n                        str = str.slice( 0, e ) + '.' + str.slice(e);                                // 987  // 995\n                    } else if ( z > 0 ) {                                                            // 988  // 996\n                        str += '.';                                                                  // 989  // 997\n                    }                                                                                // 990  // 998\n                }                                                                                    // 991  // 999\n            }                                                                                        // 992  // 1000\n                                                                                                     // 993  // 1001\n            // Append more zeros?                                                                    // 994  // 1002\n            if ( z > 0 ) for ( ; z--; str += '0' );                                                  // 995  // 1003\n        }                                                                                            // 996  // 1004\n        return n['s'] < 0 && n['c'][0] ? '-' + str : str;                                            // 997  // 1005\n    }                                                                                                // 998  // 1006\n                                                                                                     // 999  // 1007\n                                                                                                     // 1000\n    // Assemble error messages. Throw BigNumber Errors.                                              // 1001\n    function ifExceptionsThrow( arg, i, j, isArray, isRange, isErrors) {                             // 1002\n                                                                                                     // 1003\n        if (ERRORS) {                                                                                // 1004\n            var error,                                                                               // 1005\n                method = ['new BigNumber', 'cmp', 'div', 'eq', 'gt', 'gte', 'lt',                    // 1006\n                     'lte', 'minus', 'mod', 'plus', 'times', 'toFraction', 'divToInt'                // 1007\n                    ][ id ? id < 0 ? -id : id : 1 / id < 0 ? 1 : 0 ] + '()',                         // 1008\n                message = outOfRange ? ' out of range' : ' not a' +                                  // 1009\n                  ( isRange ? ' non-zero' : 'n' ) + ' integer';                                      // 1010\n                                                                                                     // 1011\n            message = ( [                                                                            // 1012\n                method + ' number type has more than 15 significant digits',                         // 1013\n                method + ' not a base ' + j + ' number',                                             // 1014\n                method + ' base' + message,                                                          // 1015\n                method + ' not a number' ][i] ||                                                     // 1016\n                  j + '() ' + i + ( isErrors                                                         // 1017\n                    ? ' not a boolean or binary digit'                                               // 1018\n                    : message + ( isArray                                                            // 1019\n                      ? ' or not [' + ( outOfRange                                                   // 1020\n                        ? ' negative, positive'                                                      // 1021\n                        : ' integer, integer' ) + ' ]'                                               // 1022\n                      : '' ) ) ) + ': ' + arg;                                                       // 1023\n                                                                                                     // 1024\n            outOfRange = id = 0;                                                                     // 1025\n            error = new Error(message);                                                              // 1026\n            error['name'] = 'BigNumber Error';                                                       // 1027\n            throw error;                                                                             // 1028\n        }                                                                                            // 1029\n    }                                                                                                // 1030\n                                                                                                     // 1031\n                                                                                                     // 1032\n    /*                                                                                               // 1033\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.           // 1034\n     */                                                                                              // 1035\n    function rnd( x, sd, rm, r ) {                                                                   // 1036\n        var d, i, j, k, n, ni, rd, xc,                                                               // 1037\n            pows10 = POWS_TEN;                                                                       // 1038\n                                                                                                     // 1039\n        // if x is not Infinity or NaN...                                                            // 1040\n        if ( xc = x['c'] ) {                                                                         // 1041\n                                                                                                     // 1042\n            // rd: the rounding digit, i.e. the digit after the digit that may be rounded up         // 1043\n            // n: a base 1e14 number, the value of the element of array x.c containing rd            // 1044\n            // ni: the index of n within x.c                                                         // 1045\n            // d: the number of digits of n                                                          // 1046\n            // i: what would be the index of rd within n if all the numbers were 14 digits long      // 1047\n            // (i.e. they had leading zeros)                                                         // 1048\n            // j: if > 0, the actual index of rd within n (if < 0, rd is a leading zero)             // 1049\n            out: {                                                                                   // 1050\n                                                                                                     // 1051\n                // Get the number of digits of the first element of xc.                              // 1052\n                for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );                                     // 1053\n                i = sd - d;                                                                          // 1054\n                                                                                                     // 1055\n                // If the rounding digit is in the first element of xc...                            // 1056\n                if ( i < 0 ) {                                                                       // 1057\n                    i += LOG_BASE;                                                                   // 1058\n                    j = sd;                                                                          // 1059\n                    n = xc[ ni = 0 ];                                                                // 1060\n                                                                                                     // 1061\n                    // Get the rounding digit at index j of n.                                       // 1062\n                    rd = n / pows10[ d - j - 1 ] % 10 | 0;                                           // 1063\n                } else {                                                                             // 1064\n                    ni = Math.ceil( ( i + 1 ) / LOG_BASE );                                          // 1065\n                                                                                                     // 1066\n                    if ( ni >= xc.length ) {                                                         // 1067\n                                                                                                     // 1068\n                        if (r) {                                                                     // 1069\n                                                                                                     // 1070\n                            // Needed by sqrt.                                                       // 1071\n                            for ( ; xc.length <= ni; xc.push(0) );                                   // 1072\n                            n = rd = 0;                                                              // 1073\n                            d = 1;                                                                   // 1074\n                            i %= LOG_BASE;                                                           // 1075\n                            j = i - LOG_BASE + 1;                                                    // 1076\n                        } else {                                                                     // 1077\n                            break out;                                                               // 1078\n                        }                                                                            // 1079\n                    } else {                                                                         // 1080\n                        n = k = xc[ni];                                                              // 1081\n                                                                                                     // 1082\n                        // Get the number of digits of n.                                            // 1083\n                        for ( d = 1; k >= 10; k /= 10, d++ );                                        // 1084\n                                                                                                     // 1085\n                        // Get the index of rd within n.                                             // 1086\n                        i %= LOG_BASE;                                                               // 1087\n                                                                                                     // 1088\n                        // Get the index of rd within n, adjusted for leading zeros.                 // 1089\n                        // The number of leading zeros of n is given by LOG_BASE - d.                // 1090\n                        j = i - LOG_BASE + d;                                                        // 1091\n                                                                                                     // 1092\n                        // Get the rounding digit at index j of n.                                   // 1093\n                        rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;                           // 1094\n                    }                                                                                // 1095\n                }                                                                                    // 1096\n                                                                                                     // 1097\n                r = r || sd < 0 ||                                                                   // 1098\n                                                                                                     // 1099\n                // Are there any non-zero digits after the rounding digit?                           // 1100\n                // The expression  n % pows10[ d - j - 1 ]  returns all the digits of n to the right // 1101\n                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.      // 1102\n                  xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );                     // 1103\n                                                                                                     // 1104\n                r = rm < 4                                                                           // 1105\n                  ? ( rd || r ) && ( rm == 0 || rm == ( x['s'] < 0 ? 3 : 2 ) )                       // 1106\n                  : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&                                // 1107\n                                                                                                     // 1108\n                    // Check whether the digit to the left of the rounding digit is odd.             // 1109\n                    ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||         // 1110\n                      rm == ( x['s'] < 0 ? 8 : 7 ) );                                                // 1111\n                                                                                                     // 1112\n                if ( sd < 1 || !xc[0] ) {                                                            // 1113\n                    xc.length = 0;                                                                   // 1114\n                                                                                                     // 1115\n                    if (r) {                                                                         // 1116\n                                                                                                     // 1117\n                        // Convert sd to decimal places.                                             // 1118\n                        sd -= x['e'] + 1;                                                            // 1119\n                                                                                                     // 1120\n                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.                                          // 1121\n                        xc[0] = pows10[ sd % LOG_BASE ];                                             // 1122\n                        x['e'] = -sd || 0;                                                           // 1123\n                    } else {                                                                         // 1124\n                                                                                                     // 1125\n                        // Zero.                                                                     // 1126\n                        xc[0] = x['e'] = 0;                                                          // 1127\n                    }                                                                                // 1128\n                                                                                                     // 1129\n                    return x;                                                                        // 1130\n                }                                                                                    // 1131\n                                                                                                     // 1132\n                // Remove excess digits.                                                             // 1133\n                if ( i == 0 ) {                                                                      // 1134\n                    xc.length = ni;                                                                  // 1135\n                    k = 1;                                                                           // 1136\n                    ni--;                                                                            // 1137\n                } else {                                                                             // 1138\n                    xc.length = ni + 1;                                                              // 1139\n                    k = pows10[ LOG_BASE - i ];                                                      // 1140\n                                                                                                     // 1141\n                    // E.g. 56700 becomes 56000 if 7 is the rounding digit.                          // 1142\n                    // j > 0 means i > number of leading zeros of n.                                 // 1143\n                    xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;           // 1144\n                }                                                                                    // 1145\n                                                                                                     // 1146\n                // Round up?                                                                         // 1147\n                if (r) {                                                                             // 1148\n                                                                                                     // 1149\n                    for ( ; ; ) {                                                                    // 1150\n                                                                                                     // 1151\n                        // If the digit to be rounded up is in the first element of xc...            // 1152\n                        if ( ni == 0 ) {                                                             // 1153\n                                                                                                     // 1154\n                            // i will be the length of xc[0] before k is added.                      // 1155\n                            for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );                         // 1156\n                            j = xc[0] += k;                                                          // 1157\n                            for ( k = 1; j >= 10; j /= 10, k++ );                                    // 1158\n                                                                                                     // 1159\n                            // if i != k the length has increased.                                   // 1160\n                            if ( i != k ) {                                                          // 1161\n                                x['e']++;                                                            // 1162\n                                if ( xc[0] == BASE ) xc[0] = 1;                                      // 1163\n                            }                                                                        // 1164\n                            break;                                                                   // 1165\n                        } else {                                                                     // 1166\n                            xc[ni] += k;                                                             // 1167\n                            if ( xc[ni] != BASE ) break;                                             // 1168\n                            xc[ni--] = 0;                                                            // 1169\n                            k = 1;                                                                   // 1170\n                        }                                                                            // 1171\n                    }                                                                                // 1172\n                }                                                                                    // 1173\n                                                                                                     // 1174\n                // Remove trailing zeros.                                                            // 1175\n                for ( i = xc.length; xc[--i] === 0; xc.pop() );                                      // 1176\n            }                                                                                        // 1177\n                                                                                                     // 1178\n            // Overflow? Infinity.                                                                   // 1179\n            if ( x['e'] > MAX_EXP ) {                                                                // 1180\n                x['c'] = x['e'] = null;                                                              // 1181\n                                                                                                     // 1182\n            // Underflow? Zero.                                                                      // 1183\n            } else if ( x['e'] < MIN_EXP ) {                                                         // 1184\n                x['c'] = [ x['e'] = 0 ];                                                             // 1185\n            }                                                                                        // 1186\n        }                                                                                            // 1187\n                                                                                                     // 1188\n        return x;                                                                                    // 1189\n    }                                                                                                // 1190\n                                                                                                     // 1191\n                                                                                                     // 1192\n    // PROTOTYPE/INSTANCE METHODS                                                                    // 1193\n                                                                                                     // 1194\n                                                                                                     // 1195\n    /*                                                                                               // 1196\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.                   // 1197\n     */                                                                                              // 1198\n    P['absoluteValue'] = P['abs'] = function () {                                                    // 1199\n        var x = new BigNumber(this);                                                                 // 1200\n        if ( x['s'] < 0 ) x['s'] = 1;                                                                // 1201\n        return x;                                                                                    // 1202\n    };                                                                                               // 1203\n                                                                                                     // 1204\n                                                                                                     // 1205\n    /*                                                                                               // 1206\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole number   // 1207\n     * in the direction of Infinity.                                                                 // 1208\n     */                                                                                              // 1209\n    P['ceil'] = function () {                                                                        // 1210\n        return rnd( new BigNumber(this), this['e'] + 1, 2 );                                         // 1211\n    };                                                                                               // 1212\n                                                                                                     // 1213\n                                                                                                     // 1214\n    /*                                                                                               // 1215\n     * Return                                                                                        // 1216\n     * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),                // 1217\n     * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),                  // 1218\n     * 0 if they have the same value,                                                                // 1219\n     * or null if the value of either is NaN.                                                        // 1220\n     */                                                                                              // 1221\n    P['comparedTo'] = P['cmp'] = function ( y, b ) {                                                 // 1222\n        var a,                                                                                       // 1223\n            x = this,                                                                                // 1224\n            xc = x['c'],                                                                             // 1225\n            yc = ( id = -id, y = new BigNumber( y, b ) )['c'],                                       // 1226\n            i = x['s'],                                                                              // 1227\n            j = y['s'],                                                                              // 1228\n            k = x['e'],                                                                              // 1229\n            l = y['e'];                                                                              // 1230\n                                                                                                     // 1231\n        // Either NaN?                                                                               // 1232\n        if ( !i || !j ) return null;                                                                 // 1233\n                                                                                                     // 1234\n        a = xc && !xc[0];                                                                            // 1235\n        b = yc && !yc[0];                                                                            // 1236\n                                                                                                     // 1237\n        // Either zero?                                                                              // 1238\n        if ( a || b ) return a ? b ? 0 : -j : i;                                                     // 1239\n                                                                                                     // 1240\n        // Signs differ?                                                                             // 1241\n        if ( i != j ) return i;                                                                      // 1242\n                                                                                                     // 1243\n        a = i < 0;                                                                                   // 1244\n        b = k == l;                                                                                  // 1245\n                                                                                                     // 1246\n        // Either Infinity?                                                                          // 1247\n        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;                                           // 1248\n                                                                                                     // 1249\n        // Compare exponents.                                                                        // 1250\n        if ( !b ) return k > l ^ a ? 1 : -1;                                                         // 1251\n        i = -1;                                                                                      // 1252\n        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;                                           // 1253\n                                                                                                     // 1254\n        // Compare digit by digit.                                                                   // 1255\n        for ( ; ++i < j; ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;                  // 1256\n                                                                                                     // 1257\n        // Compare lengths.                                                                          // 1258\n        return k == l ? 0 : k > l ^ a ? 1 : -1;                                                      // 1259\n    };                                                                                               // 1260\n                                                                                                     // 1261\n                                                                                                     // 1262\n    /*                                                                                               // 1263\n     * Return the number of decimal places of the value of this BigNumber, or null if the value of   // 1264\n     * this BigNumber is +-Infinity or NaN.                                                          // 1265\n     */                                                                                              // 1266\n    P['decimalPlaces'] = P['dp'] = function () {                                                     // 1267\n        var n, v,                                                                                    // 1268\n            c = this['c'];                                                                           // 1269\n                                                                                                     // 1270\n        if ( !c ) return null;                                                                       // 1271\n        n = ( ( v = c.length - 1 ) - mathfloor( this['e'] / LOG_BASE ) ) * LOG_BASE;                 // 1272\n                                                                                                     // 1273\n        // Subtract the number of trailing zeros of the last number.                                 // 1274\n        if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );                                         // 1275\n        if ( n < 0 ) n = 0;                                                                          // 1276\n                                                                                                     // 1277\n        return n;                                                                                    // 1278\n    };                                                                                               // 1279\n                                                                                                     // 1280\n                                                                                                     // 1281\n    /*                                                                                               // 1282\n     *  n / 0 = I                                                                                    // 1283\n     *  n / N = N                                                                                    // 1284\n     *  n / I = 0                                                                                    // 1285\n     *  0 / n = 0                                                                                    // 1286\n     *  0 / 0 = N                                                                                    // 1287\n     *  0 / N = N                                                                                    // 1288\n     *  0 / I = 0                                                                                    // 1289\n     *  N / n = N                                                                                    // 1290\n     *  N / 0 = N                                                                                    // 1291\n     *  N / N = N                                                                                    // 1292\n     *  N / I = N                                                                                    // 1293\n     *  I / n = I                                                                                    // 1294\n     *  I / 0 = I                                                                                    // 1295\n     *  I / N = N                                                                                    // 1296\n     *  I / I = N                                                                                    // 1297\n     *                                                                                               // 1298\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of     // 1299\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.                       // 1300\n     */                                                                                              // 1301\n    P['dividedBy'] = P['div'] = function ( y, b ) {                                                  // 1302\n        id = 2;                                                                                      // 1303\n        return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );                    // 1304\n    };                                                                                               // 1305\n                                                                                                     // 1306\n                                                                                                     // 1307\n    /*                                                                                               // 1308\n     * Return a new BigNumber whose value is the integer part of dividing the value of this          // 1309\n     * BigNumber by the value of BigNumber(y, b).                                                    // 1310\n     */                                                                                              // 1311\n    P['dividedToIntegerBy'] = P['divToInt'] = function ( y, b ) {                                    // 1312\n        id = 13;                                                                                     // 1313\n        return div( this, new BigNumber( y, b ), 0, 1 );                                             // 1314\n    };                                                                                               // 1315\n                                                                                                     // 1316\n                                                                                                     // 1317\n    /*                                                                                               // 1318\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(n, b),          // 1319\n     * otherwise returns false.                                                                      // 1320\n     */                                                                                              // 1321\n    P['equals'] = P['eq'] = function ( n, b ) {                                                      // 1322\n        id = 3;                                                                                      // 1323\n        return this['cmp']( n, b ) === 0;                                                            // 1324\n    };                                                                                               // 1325\n                                                                                                     // 1326\n                                                                                                     // 1327\n    /*                                                                                               // 1328\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole number   // 1329\n     * in the direction of -Infinity.                                                                // 1330\n     */                                                                                              // 1331\n    P['floor'] = function () {                                                                       // 1332\n        return rnd( new BigNumber(this), this['e'] + 1, 3 );                                         // 1333\n    };                                                                                               // 1334\n                                                                                                     // 1335\n                                                                                                     // 1336\n    /*                                                                                               // 1337\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(n, b),      // 1338\n     * otherwise returns false.                                                                      // 1339\n     */                                                                                              // 1340\n    P['greaterThan'] = P['gt'] = function ( n, b ) {                                                 // 1341\n        id = 4;                                                                                      // 1342\n        return this['cmp']( n, b ) > 0;                                                              // 1343\n    };                                                                                               // 1344\n                                                                                                     // 1345\n                                                                                                     // 1346\n    /*                                                                                               // 1347\n     * Return true if the value of this BigNumber is greater than or equal to the value of           // 1348\n     * BigNumber(n, b), otherwise returns false.                                                     // 1349\n     */                                                                                              // 1350\n    P['greaterThanOrEqualTo'] = P['gte'] = function ( n, b ) {                                       // 1351\n        id = 5;                                                                                      // 1352\n        return ( b = this['cmp']( n, b ) ) == 1 || b === 0;                                          // 1353\n    };                                                                                               // 1354\n                                                                                                     // 1355\n                                                                                                     // 1356\n    /*                                                                                               // 1357\n     * Return true if the value of this BigNumber is a finite number, otherwise returns false.       // 1358\n     */                                                                                              // 1359\n    P['isFinite'] = function () {                                                                    // 1360\n        return !!this['c'];                                                                          // 1361\n    };                                                                                               // 1362\n                                                                                                     // 1363\n                                                                                                     // 1364\n    /*                                                                                               // 1365\n     * Return true if the value of this BigNumber is an integer, otherwise return false.             // 1366\n     */                                                                                              // 1367\n    P['isInteger'] = P['isInt'] = function () {                                                      // 1368\n        return !!this['c'] && mathfloor( this['e'] / LOG_BASE ) > this['c'].length - 2;              // 1369\n    };                                                                                               // 1370\n                                                                                                     // 1371\n                                                                                                     // 1372\n    /*                                                                                               // 1373\n     * Return true if the value of this BigNumber is NaN, otherwise returns false.                   // 1374\n     */                                                                                              // 1375\n    P['isNaN'] = function () {                                                                       // 1376\n        return !this['s'];                                                                           // 1377\n    };                                                                                               // 1378\n                                                                                                     // 1379\n                                                                                                     // 1380\n    /*                                                                                               // 1381\n     * Return true if the value of this BigNumber is negative, otherwise returns false.              // 1382\n     */                                                                                              // 1383\n    P['isNegative'] = P['isNeg'] = function () {                                                     // 1384\n        return this['s'] < 0;                                                                        // 1385\n    };                                                                                               // 1386\n                                                                                                     // 1387\n                                                                                                     // 1388\n    /*                                                                                               // 1389\n     * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.               // 1390\n     */                                                                                              // 1391\n    P['isZero'] = function () {                                                                      // 1392\n        return !!this['c'] && this['c'][0] == 0;                                                     // 1393\n    };                                                                                               // 1394\n                                                                                                     // 1395\n                                                                                                     // 1396\n    /*                                                                                               // 1397\n     * Return true if the value of this BigNumber is less than the value of BigNumber(n, b),         // 1398\n     * otherwise returns false.                                                                      // 1399\n     */                                                                                              // 1400\n    P['lessThan'] = P['lt'] = function ( n, b ) {                                                    // 1401\n        id = 6;                                                                                      // 1402\n        return this['cmp']( n, b ) < 0;                                                              // 1403\n    };                                                                                               // 1404\n                                                                                                     // 1405\n                                                                                                     // 1406\n    /*                                                                                               // 1407\n     * Return true if the value of this BigNumber is less than or equal to the value of              // 1408\n     * BigNumber(n, b), otherwise returns false.                                                     // 1409\n     */                                                                                              // 1410\n    P['lessThanOrEqualTo'] = P['lte'] = function ( n, b ) {                                          // 1411\n        id = 7;                                                                                      // 1412\n        return ( b = this['cmp']( n, b ) ) == -1 || b === 0;                                         // 1413\n    };                                                                                               // 1414\n                                                                                                     // 1415\n                                                                                                     // 1416\n    /*                                                                                               // 1417\n     *  n - 0 = n                                                                                    // 1418\n     *  n - N = N                                                                                    // 1419\n     *  n - I = -I                                                                                   // 1420\n     *  0 - n = -n                                                                                   // 1421\n     *  0 - 0 = 0                                                                                    // 1422\n     *  0 - N = N                                                                                    // 1423\n     *  0 - I = -I                                                                                   // 1424\n     *  N - n = N                                                                                    // 1425\n     *  N - 0 = N                                                                                    // 1426\n     *  N - N = N                                                                                    // 1427\n     *  N - I = N                                                                                    // 1428\n     *  I - n = I                                                                                    // 1429\n     *  I - 0 = I                                                                                    // 1430\n     *  I - N = N                                                                                    // 1431\n     *  I - I = N                                                                                    // 1432\n     *                                                                                               // 1433\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of          // 1434\n     * BigNumber(y, b).                                                                              // 1435\n     */                                                                                              // 1436\n    P['minus'] = function ( y, b ) {                                                                 // 1437\n        var i, j, t, xLTy,                                                                           // 1438\n            x = this,                                                                                // 1439\n            a = x['s'];                                                                              // 1440\n                                                                                                     // 1441\n        id = 8;                                                                                      // 1442\n        y = new BigNumber( y, b );                                                                   // 1443\n        b = y['s'];                                                                                  // 1444\n                                                                                                     // 1445\n        // Either NaN?                                                                               // 1446\n        if ( !a || !b ) return new BigNumber(NaN);                                                   // 1447\n                                                                                                     // 1448\n        // Signs differ?                                                                             // 1449\n        if ( a != b ) {                                                                              // 1450\n            y['s'] = -b;                                                                             // 1451\n            return x['plus'](y);                                                                     // 1452\n        }                                                                                            // 1453\n                                                                                                     // 1454\n        var xe = x['e'] / LOG_BASE,                                                                  // 1455\n            ye = y['e'] / LOG_BASE,                                                                  // 1456\n            xc = x['c'],                                                                             // 1457\n            yc = y['c'];                                                                             // 1458\n                                                                                                     // 1459\n        if ( !xe || !ye ) {                                                                          // 1460\n                                                                                                     // 1461\n            // Either Infinity?                                                                      // 1462\n            if ( !xc || !yc ) return xc ? ( y['s'] = -b, y ) : new BigNumber( yc ? x : NaN );        // 1463\n                                                                                                     // 1464\n            // Either zero?                                                                          // 1465\n            if ( !xc[0] || !yc[0] ) {                                                                // 1466\n                                                                                                     // 1467\n                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.          // 1468\n                return yc[0] ? ( y['s'] = -b, y ) : new BigNumber( xc[0] ? x :                       // 1469\n                                                                                                     // 1470\n                  // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity                      // 1471\n                  ROUNDING_MODE == 3 ? -0 : 0 );                                                     // 1472\n            }                                                                                        // 1473\n        }                                                                                            // 1474\n                                                                                                     // 1475\n        // Floor xe and ye                                                                           // 1476\n        i = xe | 0;                                                                                  // 1477\n        xe = xe > 0 || xe === i ? i : i - 1;                                                         // 1478\n        i = ye | 0;                                                                                  // 1479\n        ye = ye > 0 || ye === i ? i : i - 1;                                                         // 1480\n        xc = xc.slice();                                                                             // 1481\n                                                                                                     // 1482\n        // Determine which is the bigger number.                                                     // 1483\n        if ( a = xe - ye ) {                                                                         // 1484\n                                                                                                     // 1485\n            if ( xLTy = a < 0 ) {                                                                    // 1486\n                a = -a, t = xc;                                                                      // 1487\n            } else {                                                                                 // 1488\n                ye = xe, t = yc;                                                                     // 1489\n            }                                                                                        // 1490\n                                                                                                     // 1491\n            // Prepend zeros to equalise exponents.                                                  // 1492\n            for ( t.reverse(), b = a; b--; t.push(0) );                                              // 1493\n            t.reverse();                                                                             // 1494\n        } else {                                                                                     // 1495\n                                                                                                     // 1496\n            // Exponents equal. Check digit by digit.                                                // 1497\n            j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;                            // 1498\n                                                                                                     // 1499\n            for ( a = b = 0; b < j; b++ ) {                                                          // 1500\n                                                                                                     // 1501\n                if ( xc[b] != yc[b] ) {                                                              // 1502\n                    xLTy = xc[b] < yc[b];                                                            // 1503\n                    break;                                                                           // 1504\n                }                                                                                    // 1505\n            }                                                                                        // 1506\n        }                                                                                            // 1507\n                                                                                                     // 1508\n        // x < y? Point xc to the array of the bigger number.                                        // 1509\n        if (xLTy) t = xc, xc = yc, yc = t, y['s'] = -y['s'];                                         // 1510\n                                                                                                     // 1511\n        b = ( j = yc.length ) - ( i = xc.length );                                                   // 1512\n                                                                                                     // 1513\n        // Append zeros to xc if shorter.                                                            // 1514\n        // No need to add zeros to yc if shorter as subtraction only needs to start at yc.length.    // 1515\n        if ( b > 0 ) for ( ; b--; xc[i++] = 0 );                                                     // 1516\n        b = BASE - 1;                                                                                // 1517\n                                                                                                     // 1518\n        // Subtract yc from xc.                                                                      // 1519\n        for ( ; j > a; ) {                                                                           // 1520\n                                                                                                     // 1521\n            if ( xc[--j] < yc[j] ) {                                                                 // 1522\n                for ( i = j; i && !xc[--i]; xc[i] = b );                                             // 1523\n                --xc[i];                                                                             // 1524\n                xc[j] += BASE;                                                                       // 1525\n            }                                                                                        // 1526\n            xc[j] -= yc[j];                                                                          // 1527\n        }                                                                                            // 1528\n                                                                                                     // 1529\n        // Remove leading zeros and adjust exponent accordingly.                                     // 1530\n        for ( ; xc[0] == 0; xc.shift(), --ye );                                                      // 1531\n                                                                                                     // 1532\n        // Zero?                                                                                     // 1533\n        if ( !xc[0] ) {                                                                              // 1534\n                                                                                                     // 1535\n            // Following IEEE 754 (2008) 6.3,                                                        // 1536\n            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.                         // 1537\n            y['s'] = ROUNDING_MODE == 3 ? -1 : 1;                                                    // 1538\n            y['c'] = [ y['e'] = 0 ];                                                                 // 1539\n            return y;                                                                                // 1540\n        }                                                                                            // 1541\n                                                                                                     // 1542\n        // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity when neither  // 1543\n        // x or y are Infinity.                                                                      // 1544\n        return normalise( y, xc, ye );                                                               // 1545\n    };                                                                                               // 1546\n                                                                                                     // 1547\n                                                                                                     // 1548\n    /*                                                                                               // 1549\n     *   n % 0 =  N                                                                                  // 1550\n     *   n % N =  N                                                                                  // 1551\n     *   0 % n =  0                                                                                  // 1552\n     *  -0 % n = -0                                                                                  // 1553\n     *   0 % 0 =  N                                                                                  // 1554\n     *   0 % N =  N                                                                                  // 1555\n     *   N % n =  N                                                                                  // 1556\n     *   N % 0 =  N                                                                                  // 1557\n     *   N % N =  N                                                                                  // 1558\n     *                                                                                               // 1559\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of         // 1560\n     * BigNumber(y, b).                                                                              // 1561\n     */                                                                                              // 1562\n    P['modulo'] = P['mod'] = function ( y, b ) {                                                     // 1563\n        id = 9;                                                                                      // 1564\n        var x = this,                                                                                // 1565\n            xc = x['c'],                                                                             // 1566\n            yc = ( y = new BigNumber( y, b ) )['c'],                                                 // 1567\n            xs = x['s'],                                                                             // 1568\n            ys = y['s'];                                                                             // 1569\n                                                                                                     // 1570\n        // x or y NaN? y zero? x zero?                                                               // 1571\n        b = !xs || !ys || yc && !yc[0];                                                              // 1572\n        if ( b || xc && !xc[0] ) return new BigNumber( b ? NaN : x );                                // 1573\n                                                                                                     // 1574\n        x['s'] = y['s'] = 1;                                                                         // 1575\n        b = y['cmp'](x) == 1;                                                                        // 1576\n        x['s'] = xs;                                                                                 // 1577\n        y['s'] = ys;                                                                                 // 1578\n                                                                                                     // 1579\n        return b ? new BigNumber(x) : x['minus']( div( x, y, 0, 1 )['times'](y) );                   // 1580\n    };                                                                                               // 1581\n                                                                                                     // 1582\n                                                                                                     // 1583\n    /*                                                                                               // 1584\n     * Return a new BigNumber whose value is the value of this BigNumber negated, i.e. multiplied    // 1585\n     * by -1.                                                                                        // 1586\n     */                                                                                              // 1587\n    P['negated'] = P['neg'] = function () {                                                          // 1588\n        var x = new BigNumber(this);                                                                 // 1589\n        x['s'] = -x['s'] || null;                                                                    // 1590\n        return x;                                                                                    // 1591\n    };                                                                                               // 1592\n                                                                                                     // 1593\n                                                                                                     // 1594\n    /*                                                                                               // 1595\n     *  n + 0 = n                                                                                    // 1596\n     *  n + N = N                                                                                    // 1597\n     *  n + I = I                                                                                    // 1598\n     *  0 + n = n                                                                                    // 1599\n     *  0 + 0 = 0                                                                                    // 1600\n     *  0 + N = N                                                                                    // 1601\n     *  0 + I = I                                                                                    // 1602\n     *  N + n = N                                                                                    // 1603\n     *  N + 0 = N                                                                                    // 1604\n     *  N + N = N                                                                                    // 1605\n     *  N + I = N                                                                                    // 1606\n     *  I + n = I                                                                                    // 1607\n     *  I + 0 = I                                                                                    // 1608\n     *  I + N = N                                                                                    // 1609\n     *  I + I = I                                                                                    // 1610\n     *                                                                                               // 1611\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of           // 1612\n     * BigNumber(y, b).                                                                              // 1613\n     */                                                                                              // 1614\n    P['plus'] = function ( y, b ) {                                                                  // 1615\n        var t,                                                                                       // 1616\n            x = this,                                                                                // 1617\n            a = x['s'];                                                                              // 1618\n                                                                                                     // 1619\n        id = 10;                                                                                     // 1620\n        y = new BigNumber( y, b );                                                                   // 1621\n        b = y['s'];                                                                                  // 1622\n                                                                                                     // 1623\n        // Either NaN?                                                                               // 1624\n        if ( !a || !b ) return new BigNumber(NaN);                                                   // 1625\n                                                                                                     // 1626\n        // Signs differ?                                                                             // 1627\n         if ( a != b ) {                                                                             // 1628\n            y['s'] = -b;                                                                             // 1629\n            return x['minus'](y);                                                                    // 1630\n        }                                                                                            // 1631\n                                                                                                     // 1632\n        var xe = x['e'] / LOG_BASE,                                                                  // 1633\n            ye = y['e'] / LOG_BASE,                                                                  // 1634\n            xc = x['c'],                                                                             // 1635\n            yc = y['c'];                                                                             // 1636\n                                                                                                     // 1637\n        if ( !xe || !ye ) {                                                                          // 1638\n                                                                                                     // 1639\n            // Return +-Infinity if either Infinity.                                                 // 1640\n            if ( !xc || !yc ) return new BigNumber( a / 0 );                                         // 1641\n                                                                                                     // 1642\n            // Either zero? Return y if y is non-zero, x if x is non-zero, or zero if both are zero. // 1643\n            if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );           // 1644\n        }                                                                                            // 1645\n                                                                                                     // 1646\n         // Floor xe and ye                                                                          // 1647\n        a = xe | 0;                                                                                  // 1648\n        xe = xe > 0 || xe === a ? a : a - 1;                                                         // 1649\n        a = ye | 0;                                                                                  // 1650\n        ye = ye > 0 || ye === a ? a : a - 1;                                                         // 1651\n        xc = xc.slice();                                                                             // 1652\n                                                                                                     // 1653\n        // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.              // 1654\n        if ( a = xe - ye ) {                                                                         // 1655\n            if ( a > 0 ) {                                                                           // 1656\n                ye = xe, t = yc;                                                                     // 1657\n            } else {                                                                                 // 1658\n                a = -a, t = xc;                                                                      // 1659\n            }                                                                                        // 1660\n                                                                                                     // 1661\n            for ( t.reverse(); a--; t.push(0) );                                                     // 1662\n            t.reverse();                                                                             // 1663\n        }                                                                                            // 1664\n        a = xc.length;                                                                               // 1665\n        b = yc.length;                                                                               // 1666\n                                                                                                     // 1667\n        // Point xc to the longer array, and b to the shorter length.                                // 1668\n        if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;                                             // 1669\n                                                                                                     // 1670\n        // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.   // 1671\n        for ( a = 0; b; ) {                                                                          // 1672\n            a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;                                          // 1673\n            xc[b] %= BASE;                                                                           // 1674\n        }                                                                                            // 1675\n                                                                                                     // 1676\n                                                                                                     // 1677\n        if (a) {                                                                                     // 1678\n            xc.unshift(a);                                                                           // 1679\n            ++ye;                                                                                    // 1680\n        }                                                                                            // 1681\n                                                                                                     // 1682\n        // No need to check for zero, as +x + +y != 0 && -x + -y != 0                                // 1683\n        // ye = MAX_EXP + 1 possible                                                                 // 1684\n        return normalise( y, xc, ye );                                                               // 1685\n    };                                                                                               // 1686\n                                                                                                     // 1687\n                                                                                                     // 1688\n    /*                                                                                               // 1689\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of dp  // 1690\n     * decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if omitted.     // 1691\n     *                                                                                               // 1692\n     * [dp] {number} Integer, 0 to MAX inclusive.                                                    // 1693\n     * [rm] {number} Integer, 0 to 8 inclusive.                                                      // 1694\n     */                                                                                              // 1695\n    P['round'] = function ( dp, rm ) {                                                               // 1696\n                                                                                                     // 1697\n        dp = dp == null || ( ( ( outOfRange = dp < 0 || dp > MAX ) || parse(dp) != dp ) &&           // 1698\n                                                                                                     // 1699\n          // 'round() decimal places out of range: {dp}'                                             // 1700\n          // 'round() decimal places not an integer: {dp}'                                           // 1701\n          !ifExceptionsThrow( dp, 'decimal places', 'round' ) ) ? 0 : dp | 0;                        // 1702\n                                                                                                     // 1703\n        // Include '&& rm !== 0' because with Opera -0 == parseFloat(-0) is false.                   // 1704\n        rm = rm == null || ( ( ( outOfRange = rm < 0 || rm > 8 ) || parse(rm) != rm && rm !== 0 ) && // 1705\n                                                                                                     // 1706\n          // 'round() mode not an integer: {rm}'                                                     // 1707\n          // 'round() mode out of range: {rm}'                                                       // 1708\n          !ifExceptionsThrow( rm, 'mode', 'round' ) ) ? ROUNDING_MODE : rm | 0;                      // 1709\n                                                                                                     // 1710\n        return rnd( new BigNumber(this), dp + this['e'] + 1, rm );                                   // 1711\n    };                                                                                               // 1712\n                                                                                                     // 1713\n                                                                                                     // 1714\n    /*                                                                                               // 1715\n     *  sqrt(-n) =  N                                                                                // 1716\n     *  sqrt( N) =  N                                                                                // 1717\n     *  sqrt(-I) =  N                                                                                // 1718\n     *  sqrt( I) =  I                                                                                // 1719\n     *  sqrt( 0) =  0                                                                                // 1720\n     *  sqrt(-0) = -0                                                                                // 1721\n     *                                                                                               // 1722\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,         // 1723\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.                                        // 1724\n     */                                                                                              // 1725\n    P['squareRoot'] = P['sqrt'] = function () {                                                      // 1726\n        var m, n, r, rep, t,                                                                         // 1727\n            x = this,                                                                                // 1728\n            c = x['c'],                                                                              // 1729\n            s = x['s'],                                                                              // 1730\n            e = x['e'],                                                                              // 1731\n            dp = DECIMAL_PLACES + 4,                                                                 // 1732\n            half = new BigNumber('0.5');                                                             // 1733\n                                                                                                     // 1734\n        // Negative/NaN/Infinity/zero?                                                               // 1735\n        if ( s !== 1 || !c || !c[0] ) {                                                              // 1736\n            return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );             // 1737\n        }                                                                                            // 1738\n                                                                                                     // 1739\n        // Initial estimate.                                                                         // 1740\n        s = Math.sqrt( +x );                                                                         // 1741\n                                                                                                     // 1742\n        // Math.sqrt underflow/overflow?                                                             // 1743\n        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.                   // 1744\n        if ( s == 0 || s == 1 / 0 ) {                                                                // 1745\n            n = coefficientToString(c);                                                              // 1746\n            if ( ( n.length + e ) % 2 == 0 ) n += '0';                                               // 1747\n            s = Math.sqrt(n);                                                                        // 1748\n            e = mathfloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );                                     // 1749\n                                                                                                     // 1750\n            if ( s == 1 / 0 ) {                                                                      // 1751\n                n = '1e' + e;                                                                        // 1752\n            } else {                                                                                 // 1753\n                n = s.toExponential();                                                               // 1754\n                n = n.slice( 0, n.indexOf('e') + 1 ) + e;                                            // 1755\n            }                                                                                        // 1756\n            r = new BigNumber(n);                                                                    // 1757\n        } else {                                                                                     // 1758\n            r = new BigNumber( s.toString() );                                                       // 1759\n        }                                                                                            // 1760\n                                                                                                     // 1761\n        // Check for zero. r could be zero if MIN_EXP is changed after the this value was created.   // 1762\n        // This would cause a division by zero (x/t) and hence Infinity below, which would cause     // 1763\n        // coefficientToString to throw.                                                             // 1764\n        if ( r['c'][0] ) {                                                                           // 1765\n            e = r['e'];                                                                              // 1766\n            s = e + dp;                                                                              // 1767\n            if ( s < 3 ) s = 0;                                                                      // 1768\n                                                                                                     // 1769\n            // Newton-Raphson iteration.                                                             // 1770\n            for ( ; ; ) {                                                                            // 1771\n                t = r;                                                                               // 1772\n                r = half['times']( t['plus']( div( x, t, dp, 1 ) ) );                                // 1773\n                                                                                                     // 1774\n                if ( coefficientToString( t['c']   ).slice( 0, s ) === ( n =                         // 1775\n                     coefficientToString( r['c'] ) ).slice( 0, s ) ) {                               // 1776\n                                                                                                     // 1777\n                    // The exponent of r may here be one less than the final result exponent,        // 1778\n                    // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits are   // 1779\n                    // indexed correctly.                                                            // 1780\n                    if ( r['e'] < e ) --s;                                                           // 1781\n                    n = n.slice( s - 3, s + 1 );                                                     // 1782\n                                                                                                     // 1783\n                    // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are  // 1784\n                    // 9999 or 4999 (i.e. approaching a rounding boundary) continue the iteration.   // 1785\n                    if ( n == '9999' || !rep && n == '4999' ) {                                      // 1786\n                                                                                                     // 1787\n                        // On the first iteration only, check to see if rounding up gives the exact  // 1788\n                        // result as the nines may infinitely repeat.                                // 1789\n                        if ( !rep ) {                                                                // 1790\n                            rnd( t, t['e'] + DECIMAL_PLACES + 2, 0 );                                // 1791\n                                                                                                     // 1792\n                            if ( t['times'](t)['eq'](x) ) {                                          // 1793\n                                r = t;                                                               // 1794\n                                break;                                                               // 1795\n                            }                                                                        // 1796\n                        }                                                                            // 1797\n                        dp += 4;                                                                     // 1798\n                        s += 4;                                                                      // 1799\n                        rep = 1;                                                                     // 1800\n                    } else {                                                                         // 1801\n                                                                                                     // 1802\n                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact result.   // 1803\n                        // If not, then there are further digits and m will be truthy.               // 1804\n                        if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {                           // 1805\n                                                                                                     // 1806\n                            // Truncate to the first rounding digit.                                 // 1807\n                            rnd( r, r['e'] + DECIMAL_PLACES + 2, 1 );                                // 1808\n                            m = !r['times'](r)['eq'](x);                                             // 1809\n                        }                                                                            // 1810\n                        break;                                                                       // 1811\n                    }                                                                                // 1812\n                }                                                                                    // 1813\n            }                                                                                        // 1814\n        }                                                                                            // 1815\n                                                                                                     // 1816\n        return rnd( r, r['e'] + DECIMAL_PLACES + 1, ROUNDING_MODE, m );                              // 1817\n    };                                                                                               // 1818\n                                                                                                     // 1819\n                                                                                                     // 1820\n    /*                                                                                               // 1821\n     *  n * 0 = 0                                                                                    // 1822\n     *  n * N = N                                                                                    // 1823\n     *  n * I = I                                                                                    // 1824\n     *  0 * n = 0                                                                                    // 1825\n     *  0 * 0 = 0                                                                                    // 1826\n     *  0 * N = N                                                                                    // 1827\n     *  0 * I = N                                                                                    // 1828\n     *  N * n = N                                                                                    // 1829\n     *  N * 0 = N                                                                                    // 1830\n     *  N * N = N                                                                                    // 1831\n     *  N * I = N                                                                                    // 1832\n     *  I * n = I                                                                                    // 1833\n     *  I * 0 = N                                                                                    // 1834\n     *  I * N = N                                                                                    // 1835\n     *  I * I = I                                                                                    // 1836\n     *                                                                                               // 1837\n     * Return a new BigNumber whose value is the value of this BigNumber times the value of          // 1838\n     * BigNumber(y, b).                                                                              // 1839\n     */                                                                                              // 1840\n    P['times'] = function ( y, b ) {                                                                 // 1841\n        var c, e, k, m, r, xlo, xhi, ylo, yhi,                                                       // 1842\n            x = this,                                                                                // 1843\n            xc = x['c'],                                                                             // 1844\n            yc = ( id = 11, y = new BigNumber( y, b ) )['c'],                                        // 1845\n            i = x['e'] / LOG_BASE,                                                                   // 1846\n            j = y['e'] / LOG_BASE,                                                                   // 1847\n            a = x['s'];                                                                              // 1848\n                                                                                                     // 1849\n        y['s'] = a == ( b = y['s'] ) ? 1 : -1;                                                       // 1850\n                                                                                                     // 1851\n        // Either NaN/Infinity/0?                                                                    // 1852\n        if ( !i && ( !xc || !xc[0] ) || !j && ( !yc || !yc[0] ) ) {                                  // 1853\n                                                                                                     // 1854\n            // Return NaN if either NaN, or x is 0 and y is Infinity, or y is 0 and x is Infinity.   // 1855\n            return new BigNumber( !a || !b || xc && !xc[0] && !yc || yc && !yc[0] && !xc ? NaN       // 1856\n                                                                                                     // 1857\n              // Return +-Infinity if either is Infinity. Return +-0 if x or y is 0.                 // 1858\n              : !xc || !yc ? y['s'] / 0 : y['s'] * 0 );                                              // 1859\n        }                                                                                            // 1860\n                                                                                                     // 1861\n        // e = mathfloor(i) + mathfloor(j);                                                          // 1862\n        e = ( e = i | 0, i > 0 || i === e ? e : e - 1) +                                             // 1863\n            ( e = j | 0, j > 0 || j === e ? e : e - 1);                                              // 1864\n                                                                                                     // 1865\n        a = xc.length;                                                                               // 1866\n        b = yc.length;                                                                               // 1867\n                                                                                                     // 1868\n        // Ensure xc points to longer array and b to longer length.                                  // 1869\n        if ( a < b ) r = xc, xc = yc, yc = r, j = a, a = b, b = j;                                   // 1870\n                                                                                                     // 1871\n        // Initialise the result array with zeros.                                                   // 1872\n        for ( j = a + b, r = []; j--; r.push(0) );                                                   // 1873\n                                                                                                     // 1874\n        // Multiply!                                                                                 // 1875\n        for ( i = b; --i >= 0; ) {                                                                   // 1876\n            c = 0;                                                                                   // 1877\n            j = a + i;                                                                               // 1878\n            k = a;                                                                                   // 1879\n            ylo = yc[i] % SQRT_BASE;                                                                 // 1880\n            yhi = yc[i] / SQRT_BASE | 0;                                                             // 1881\n                                                                                                     // 1882\n            for ( ; j > i; ) {                                                                       // 1883\n                xlo = xc[--k] % SQRT_BASE;                                                           // 1884\n                xhi = xc[k] / SQRT_BASE | 0;                                                         // 1885\n                m = yhi * xlo + xhi * ylo;                                                           // 1886\n                xlo = ylo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + r[j] + c;                      // 1887\n                c = ( xlo / BASE | 0 ) + ( m / SQRT_BASE | 0 ) + yhi * xhi;                          // 1888\n                r[j--] = xlo % BASE;                                                                 // 1889\n            }                                                                                        // 1890\n            r[j] = c;                                                                                // 1891\n        }                                                                                            // 1892\n                                                                                                     // 1893\n        if (c) {                                                                                     // 1894\n            ++e;                                                                                     // 1895\n        } else {                                                                                     // 1896\n            r.shift();                                                                               // 1897\n        }                                                                                            // 1898\n                                                                                                     // 1899\n        return normalise( y, r, e );                                                                 // 1900\n    };                                                                                               // 1901\n                                                                                                     // 1902\n                                                                                                     // 1903\n    /*                                                                                               // 1904\n     * Return a string representing the value of this BigNumber in exponential notation to dp fixed  // 1905\n     * decimal places and rounded using ROUNDING_MODE if necessary.                                  // 1906\n     *                                                                                               // 1907\n     * [dp] {number} Integer, 0 to MAX inclusive.                                                    // 1908\n     */                                                                                              // 1909\n    P['toExponential'] = function (dp) {                                                             // 1910\n        var x = this;                                                                                // 1911\n                                                                                                     // 1912\n        return x['c'] ? format( x, dp == null || ( ( outOfRange = dp < 0 || dp > MAX ) ||            // 1913\n                                                                                                     // 1914\n          // Include '&& dp !== 0' because with Opera -0 == parseFloat(-0) is false,                 // 1915\n          // despite -0 == parseFloat('-0') && 0 == -0 being true.                                   // 1916\n          parse(dp) != dp && dp !== 0 ) &&                                                           // 1917\n                                                                                                     // 1918\n            // 'toExponential() decimal places not an integer: {dp}'                                 // 1919\n            // 'toExponential() decimal places out of range: {dp}'                                   // 1920\n            !ifExceptionsThrow( dp, 'decimal places', 'toExponential' )                              // 1921\n              ? null : dp | 0, 1 ) : x.toString();                                                   // 1922\n    };                                                                                               // 1923\n                                                                                                     // 1924\n                                                                                                     // 1925\n    /*                                                                                               // 1926\n     * Return a string representing the value of this BigNumber in normal notation to dp fixed       // 1927\n     * decimal places and rounded using ROUNDING_MODE if necessary.                                  // 1928\n     *                                                                                               // 1929\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',                               // 1930\n     * but e.g. (-0.00001).toFixed(0) is '-0'.                                                       // 1931\n     *                                                                                               // 1932\n     * [dp] {number} Integer, 0 to MAX inclusive.                                                    // 1933\n     */                                                                                              // 1934\n    P['toFixed'] = function (dp) {                                                                   // 1935\n        var str,                                                                                     // 1936\n            x = this,                                                                                // 1937\n            neg = TO_EXP_NEG,                                                                        // 1938\n            pos = TO_EXP_POS;                                                                        // 1939\n                                                                                                     // 1940\n        dp = dp == null || ( ( outOfRange = dp < 0 || dp > MAX ) ||                                  // 1941\n                                                                                                     // 1942\n          // 'toFixed() decimal places not an integer: {dp}'                                         // 1943\n          // 'toFixed() decimal places out of range: {dp}'                                           // 1944\n          parse(dp) != dp && dp !== 0 ) && !ifExceptionsThrow( dp, 'decimal places', 'toFixed' )     // 1945\n            ? null : x['e'] + ( dp | 0 );                                                            // 1946\n                                                                                                     // 1947\n        TO_EXP_NEG = -( TO_EXP_POS = 1 / 0 );                                                        // 1948\n                                                                                                     // 1949\n        if ( dp == null || !x['c'] ) {                                                               // 1950\n            str = x.toString();                                                                      // 1951\n        } else {                                                                                     // 1952\n            str = format( x, dp );                                                                   // 1953\n                                                                                                     // 1954\n            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.                                  // 1955\n            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.                           // 1956\n            if ( x['s'] < 0 && x['c'] ) {                                                            // 1957\n                                                                                                     // 1958\n                // As e.g. (-0).toFixed(3), will wrongly be returned as -0.000 from toString.        // 1959\n                if ( !x['c'][0] ) {                                                                  // 1960\n                    str = str.replace( '-', '' );                                                    // 1961\n                                                                                                     // 1962\n                // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.         // 1963\n                } else if ( str.indexOf('-') < 0 ) {                                                 // 1964\n                    str = '-' + str;                                                                 // 1965\n                }                                                                                    // 1966\n            }                                                                                        // 1967\n        }                                                                                            // 1968\n                                                                                                     // 1969\n        TO_EXP_NEG = neg;                                                                            // 1970\n        TO_EXP_POS = pos;                                                                            // 1971\n                                                                                                     // 1972\n        return str;                                                                                  // 1973\n    };                                                                                               // 1974\n                                                                                                     // 1975\n                                                                                                     // 1976\n    /*                                                                                               // 1977\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded      // 1978\n     * using ROUNDING_MODE to dp decimal places, and formatted according to the properties of the    // 1979\n     * FORMAT object (see BigNumber.config).                                                         // 1980\n     *                                                                                               // 1981\n     * FORMAT = {                                                                                    // 1982\n     *      decimalSeparator : '.',                                                                  // 1983\n     *      groupSeparator : ',',                                                                    // 1984\n     *      groupSize : 3,                                                                           // 1985\n     *      secondaryGroupSize : 0,                                                                  // 1986\n     *      fractionGroupSeparator : '\\xA0',    // non-breaking space                                // 1987\n     *      fractionGroupSize : 0                                                                    // 1988\n     * };                                                                                            // 1989\n     *                                                                                               // 1990\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.                                    // 1991\n     * (TODO: If dp is invalid the error message will give toFixed as the offending method.)         // 1992\n     */                                                                                              // 1993\n    P['toFormat'] = function (dp) {                                                                  // 1994\n        var x = this;                                                                                // 1995\n                                                                                                     // 1996\n        if ( !x['c'] ) return x.toString();                                                          // 1997\n                                                                                                     // 1998\n        var i,                                                                                       // 1999\n            isNeg = x['s'] < 0,                                                                      // 2000\n            groupSeparator = FORMAT['groupSeparator'],                                               // 2001\n            g1 = +FORMAT['groupSize'],                                                               // 2002\n            g2 = +FORMAT['secondaryGroupSize'],                                                      // 2003\n            arr = x.toFixed(dp).split('.'),                                                          // 2004\n            intPart = arr[0],                                                                        // 2005\n            fractionPart = arr[1],                                                                   // 2006\n            intDigits = isNeg ? intPart.slice(1) : intPart,                                          // 2007\n            len = intDigits.length;                                                                  // 2008\n                                                                                                     // 2009\n        if (g2) i = g1, g1 = g2, g2 = i, len -= i;                                                   // 2010\n                                                                                                     // 2011\n        if ( g1 > 0 && len > 0 ) {                                                                   // 2012\n            i = len % g1 || g1;                                                                      // 2013\n            intPart = intDigits.substr( 0, i );                                                      // 2014\n            for ( ; i < len; i += g1 ) intPart += groupSeparator + intDigits.substr( i, g1 );        // 2015\n            if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);                            // 2016\n            if (isNeg) intPart = '-' + intPart;                                                      // 2017\n        }                                                                                            // 2018\n                                                                                                     // 2019\n        return fractionPart                                                                          // 2020\n          ? intPart + FORMAT['decimalSeparator'] + ( ( g2 = +FORMAT['fractionGroupSize'] )           // 2021\n            ? fractionPart.replace( new RegExp( '\\\\d{' + g2 + '}\\\\B', 'g' ),                         // 2022\n              '$&' + FORMAT['fractionGroupSeparator'] )                                              // 2023\n            : fractionPart )                                                                         // 2024\n          : intPart;                                                                                 // 2025\n    };                                                                                               // 2026\n                                                                                                     // 2027\n                                                                                                     // 2028\n    /*                                                                                               // 2029\n     * Return a string array representing the value of this BigNumber as a simple fraction with an   // 2030\n     * integer numerator and an integer denominator. The denominator will be a positive non-zero     // 2031\n     * value less than or equal to the specified maximum denominator. If a maximum denominator is    // 2032\n     * not specified, the denominator will be the lowest value necessary to represent the number     // 2033\n     * exactly.                                                                                      // 2034\n     *                                                                                               // 2035\n     * [maxD] {number|string|BigNumber} Integer >= 1 and < Infinity.                                 // 2036\n     */                                                                                              // 2037\n    P['toFraction'] = function (maxD) {                                                              // 2038\n        var arr, d0, d2, e, exp, n, n0, q, s,                                                        // 2039\n            n1 = d0 = new BigNumber(ONE),                                                            // 2040\n            d1 = n0 = new BigNumber(ONE),                                                            // 2041\n            x = this,                                                                                // 2042\n            xc = x['c'],                                                                             // 2043\n            d = new BigNumber(ONE);                                                                  // 2044\n                                                                                                     // 2045\n        // NaN, Infinity.                                                                            // 2046\n        if ( !xc ) return x.toString();                                                              // 2047\n        s = coefficientToString(xc);                                                                 // 2048\n                                                                                                     // 2049\n        // Initial denominator.                                                                      // 2050\n        e = d['e'] = s.length - x['e'] - 1;                                                          // 2051\n        d['c'][0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];                   // 2052\n                                                                                                     // 2053\n        // If max denominator is undefined or null, or NaN...                                        // 2054\n        if ( maxD == null || ( !( id = 12, n = new BigNumber(maxD) )['s'] ||                         // 2055\n                                                                                                     // 2056\n               // or less than 1, or Infinity...                                                     // 2057\n               ( outOfRange = n['cmp'](n1) < 0 || !n['c'] ) ||                                       // 2058\n                                                                                                     // 2059\n                 // or not an integer...                                                             // 2060\n                 ( ERRORS && mathfloor( n['e'] / LOG_BASE ) < n['c'].length - 1 ) ) &&               // 2061\n                                                                                                     // 2062\n                   // 'toFraction() max denominator not an integer: {maxD}'                          // 2063\n                   // 'toFraction() max denominator out of range: {maxD}'                            // 2064\n                   !ifExceptionsThrow( maxD, 'max denominator', 'toFraction' ) ||                    // 2065\n                                                                                                     // 2066\n                     // or greater than the max denominator needed to specify the value exactly...   // 2067\n                     ( maxD = n )['cmp'](d) > 0 ) {                                                  // 2068\n                                                                                                     // 2069\n            // d is e.g. 10, 100, 1000, 10000... , n1 is 1.                                          // 2070\n            maxD = e > 0 ? d : n1;                                                                   // 2071\n        }                                                                                            // 2072\n                                                                                                     // 2073\n        exp = MAX_EXP;                                                                               // 2074\n        MAX_EXP = 1 / 0;                                                                             // 2075\n        n = new BigNumber(s);                                                                        // 2076\n                                                                                                     // 2077\n        // n0 = d1 = 0                                                                               // 2078\n        n0['c'][0] = 0;                                                                              // 2079\n                                                                                                     // 2080\n        for ( ; ; )  {                                                                               // 2081\n            q = div( n, d, 0, 1 );                                                                   // 2082\n            d2 = d0['plus']( q['times'](d1) );                                                       // 2083\n            if ( d2['cmp'](maxD) == 1 ) break;                                                       // 2084\n            d0 = d1;                                                                                 // 2085\n            d1 = d2;                                                                                 // 2086\n            n1 = n0['plus']( q['times']( d2 = n1 ) );                                                // 2087\n            n0 = d2;                                                                                 // 2088\n            d = n['minus']( q['times']( d2 = d ) );                                                  // 2089\n            n = d2;                                                                                  // 2090\n        }                                                                                            // 2091\n                                                                                                     // 2092\n        d2 = div( maxD['minus'](d0), d1, 0, 1 );                                                     // 2093\n        n0 = n0['plus']( d2['times'](n1) );                                                          // 2094\n        d0 = d0['plus']( d2['times'](d1) );                                                          // 2095\n        n0['s'] = n1['s'] = x['s'];                                                                  // 2096\n        e *= 2;                                                                                      // 2097\n                                                                                                     // 2098\n        // Determine which fraction is closer to x, n0/d0 or n1/d1                                   // 2099\n        arr = div( n1, d1, e, ROUNDING_MODE )['minus'](x)['abs']()['cmp'](                           // 2100\n              div( n0, d0, e, ROUNDING_MODE )['minus'](x)['abs']() ) < 1                             // 2101\n                ? [ n1.toString(), d1.toString() ]                                                   // 2102\n                : [ n0.toString(), d0.toString() ];                                                  // 2103\n                                                                                                     // 2104\n        MAX_EXP = exp;                                                                               // 2105\n                                                                                                     // 2106\n        return arr;                                                                                  // 2107\n    };                                                                                               // 2108\n                                                                                                     // 2109\n                                                                                                     // 2110\n    /*                                                                                               // 2111\n     * Return the value of this BigNumber converted to a number primitive.                           // 2112\n     */                                                                                              // 2113\n    P['toNumber'] = function () {                                                                    // 2114\n        var x = this;                                                                                // 2115\n                                                                                                     // 2116\n        // Ensure zero has correct sign.                                                             // 2117\n        return +x || ( x['s'] ? 0 * x['s'] : NaN );                                                  // 2118\n    };                                                                                               // 2119\n                                                                                                     // 2120\n                                                                                                     // 2121\n    /*                                                                                               // 2122\n     * Return a BigNumber whose value is the value of this BigNumber raised to the power e.          // 2123\n     * If e is negative round according to DECIMAL_PLACES and ROUNDING_MODE.                         // 2124\n     *                                                                                               // 2125\n     * e {number} Integer, -MAX_POWER to MAX_POWER inclusive.                                        // 2126\n     */                                                                                              // 2127\n    P['toPower'] = P['pow'] = function (e) {                                                         // 2128\n                                                                                                     // 2129\n        // e to integer, avoiding NaN or Infinity becoming 0.                                        // 2130\n        var i = e * 0 == 0 ? ~~e : e,                                                                // 2131\n            x = new BigNumber(this),                                                                 // 2132\n            y = new BigNumber(ONE);                                                                  // 2133\n                                                                                                     // 2134\n        // Pass +-Infinity for out of range exponents.                                               // 2135\n        if ( ( ( ( outOfRange = e < -MAX_POWER || e > MAX_POWER ) && (i = e * 1 / 0) ) ||            // 2136\n                                                                                                     // 2137\n            // Any exponent that fails the parse becomes NaN.                                        // 2138\n            // Include 'e !== 0' because on Opera  -0 == parseFloat(-0)  is false, despite           // 2139\n            // -0 === parseFloat(-0) && -0 == parseFloat('-0')  evaluating true.                     // 2140\n            parse(e) != e && e !== 0 && !(i = NaN) ) &&                                              // 2141\n                                                                                                     // 2142\n              // 'pow() exponent not an integer: {e}'                                                // 2143\n              // 'pow() exponent out of range: {e}'                                                  // 2144\n              // Pass zero to Math.pow, as any value to the power zero is 1.                         // 2145\n              !ifExceptionsThrow( e, 'exponent', 'pow' ) || !i ) {                                   // 2146\n                                                                                                     // 2147\n            // i is +-Infinity, NaN or 0.                                                            // 2148\n            return new BigNumber( Math.pow( +x, i ) );                                               // 2149\n        }                                                                                            // 2150\n        i = i < 0 ? -i : i;                                                                          // 2151\n                                                                                                     // 2152\n        for ( ; ; ) {                                                                                // 2153\n            if ( i & 1 ) y = y['times'](x);                                                          // 2154\n            i >>= 1;                                                                                 // 2155\n            if ( !i ) break;                                                                         // 2156\n            x = x['times'](x);                                                                       // 2157\n        }                                                                                            // 2158\n                                                                                                     // 2159\n        return e < 0 ? ONE['div'](y) : y;                                                            // 2160\n    };                                                                                               // 2161\n                                                                                                     // 2162\n                                                                                                     // 2163\n    /*                                                                                               // 2164\n     * Return a string representing the value of this BigNumber to sd significant digits and rounded // 2165\n     * using ROUNDING_MODE if necessary. If sd is less than the number of digits necessary to        // 2166\n     * represent the integer part of the value in normal notation, then use exponential notation.    // 2167\n     *                                                                                               // 2168\n     * sd {number} Integer, 1 to MAX inclusive.                                                      // 2169\n     */                                                                                              // 2170\n    P['toPrecision'] = function (sd) {                                                               // 2171\n        var x = this;                                                                                // 2172\n                                                                                                     // 2173\n         // ERRORS true: Throw if sd not undefined, null or an integer in range.                     // 2174\n         // ERRORS false: Ignore sd if not a number or not in range.                                 // 2175\n         // Truncate non-integers.                                                                   // 2176\n        return sd == null || ( ( ( outOfRange = sd < 1 || sd > MAX ) || parse(sd) != sd ) &&         // 2177\n                                                                                                     // 2178\n          // 'toPrecision() precision not an integer: {sd}'                                          // 2179\n          // 'toPrecision() precision out of range: {sd}'                                            // 2180\n          !ifExceptionsThrow( sd, 'precision', 'toPrecision' ) ) || !x['c']                          // 2181\n            ? x.toString() : format( x, --sd | 0, 2 );                                               // 2182\n    };                                                                                               // 2183\n                                                                                                     // 2184\n                                                                                                     // 2185\n    /*                                                                                               // 2186\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is        // 2187\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and     // 2188\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent that is // 2189\n     * equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than TO_EXP_NEG, // 2190\n     * return exponential notation.                                                                  // 2191\n     *                                                                                               // 2192\n     * [b] {number} Integer, 2 to 64 inclusive.                                                      // 2193\n     */                                                                                              // 2194\n    P['toString'] = function (b) {                                                                   // 2195\n        var u, str, strL,                                                                            // 2196\n            x = this,                                                                                // 2197\n            xe = x['e'];                                                                             // 2198\n                                                                                                     // 2199\n        // Infinity or NaN?                                                                          // 2200\n        if ( xe === null ) {                                                                         // 2201\n            str = x['s'] ? 'Infinity' : 'NaN';                                                       // 2202\n                                                                                                     // 2203\n        // Exponential format?                                                                       // 2204\n        } else if ( b == u && ( xe <= TO_EXP_NEG || xe >= TO_EXP_POS ) ) {                           // 2205\n            return format( x, u, 1 );                                                                // 2206\n        } else {                                                                                     // 2207\n            str = coefficientToString( x['c'] );                                                     // 2208\n                                                                                                     // 2209\n            // Negative exponent?                                                                    // 2210\n            if ( xe < 0 ) {                                                                          // 2211\n                                                                                                     // 2212\n                // Prepend zeros.                                                                    // 2213\n                for ( ; ++xe; str = '0' + str );                                                     // 2214\n                str = '0.' + str;                                                                    // 2215\n                                                                                                     // 2216\n            // Positive exponent?                                                                    // 2217\n            } else if ( strL = str.length, xe > 0 ) {                                                // 2218\n                                                                                                     // 2219\n                // Append zeros.                                                                     // 2220\n                if ( ++xe > strL ) {                                                                 // 2221\n                    for ( xe -= strL; xe-- ; str += '0' );                                           // 2222\n                } else if ( xe < strL ) {                                                            // 2223\n                    str = str.slice( 0, xe ) + '.' + str.slice(xe);                                  // 2224\n                }                                                                                    // 2225\n                                                                                                     // 2226\n            // Exponent zero.                                                                        // 2227\n            } else {                                                                                 // 2228\n                u = str.charAt(0);                                                                   // 2229\n                                                                                                     // 2230\n                if ( strL > 1 ) {                                                                    // 2231\n                    str = u + '.' + str.slice(1);                                                    // 2232\n                                                                                                     // 2233\n                // Avoid '-0'                                                                        // 2234\n                } else if ( u == '0' ) {                                                             // 2235\n                    return u;                                                                        // 2236\n                }                                                                                    // 2237\n            }                                                                                        // 2238\n                                                                                                     // 2239\n            if ( b != null ) {                                                                       // 2240\n                                                                                                     // 2241\n                if ( !( outOfRange = !( b >= 2 && b < 65 ) ) && ( b == ~~b || !ERRORS ) ) {          // 2242\n                    str = convertBase( str, b | 0, 10, x['s'] );                                     // 2243\n                                                                                                     // 2244\n                    // Avoid '-0'                                                                    // 2245\n                    if ( str == '0' ) return str;                                                    // 2246\n                } else {                                                                             // 2247\n                                                                                                     // 2248\n                    // 'toString() base not an integer: {b}'                                         // 2249\n                    // 'toString() base out of range: {b}'                                           // 2250\n                    ifExceptionsThrow( b, 'base', 'toS' );                                           // 2251\n                }                                                                                    // 2252\n            }                                                                                        // 2253\n                                                                                                     // 2254\n        }                                                                                            // 2255\n                                                                                                     // 2256\n        return x['s'] < 0 ? '-' + str : str;                                                         // 2257\n    };                                                                                               // 2258\n                                                                                                     // 2259\n                                                                                                     // 2260\n    /*                                                                                               // 2261\n     * Return as toString, but do not accept a base argument.                                        // 2262\n     */                                                                                              // 2263\n    P['valueOf'] = P['toJSON'] = function () {                                                       // 2264\n        return this.toString();                                                                      // 2265\n    };                                                                                               // 2266\n                                                                                                     // 2267\n                                                                                                     // 2268\n    // Add aliases for BigDecimal methods.                                                           // 2269\n    //P['add'] = P['plus'];                                                                          // 2270\n    //P['subtract'] = P['minus'];                                                                    // 2271\n    //P['multiply'] = P['times'];                                                                    // 2272\n    //P['divide'] = P['div'];                                                                        // 2273\n    //P['remainder'] = P['mod'];                                                                     // 2274\n    //P['compareTo'] = P['cmp'];                                                                     // 2275\n    //P['negate'] = P['neg'];                                                                        // 2276\n                                                                                                     // 2277\n                                                                                                     // 2278\n    // EXPORT                                                                                        // 2279\n                                                                                                     // 2280\n                                                                                                     // 2281\n    // Node and other CommonJS-like environments that support module.exports.                        // 2282\n    return BigNumber;                                                                                // 2283\n})();                                                                                                // 2284\n                                                                                                     // 2285\n///////////////////////////////////////////////////////////////////////////////////////////////////////      // 2294\n                                                                                                             // 2295\n}).call(this);                                                                                               // 2296\n                                                                                                             // 2297\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['3stack:bignumber'] = {}, {\n  BigNumber: BigNumber\n});\n\n})();\n","servePath":"/packages/3stack_bignumber.js"}]