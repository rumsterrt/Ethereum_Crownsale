[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar Web3 = Package['ethereum:web3'].Web3;\nvar BigNumber = Package['ethereum:web3'].BigNumber;\n\n/* Package-scope variables */\nvar EthAccounts;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ethereum_accounts/accounts.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n/**\n\n@module Ethereum:accounts\n*/\n\n\n\n/**\nThe accounts collection, with some ethereum additions.\n\n@class EthAccounts\n@constructor\n*/\nvar collection = new Mongo.Collection('ethereum_accounts', {connection: null});\nEthAccounts = _.clone(collection);\nEthAccounts._collection = collection;\n\n\nif(typeof PersistentMinimongo !== 'undefined')\n    new PersistentMinimongo(EthAccounts._collection);\n\n\n\n/**\nUpdates the accounts balances, by watching for new blocks and checking the balance.\n\n@method _watchBalance\n*/\nEthAccounts._watchBalance = function(){\n    var _this = this;\n\n    if(this.blockSubscription) {\n        this.blockSubscription.stopWatching();\n    }\n\n    // UPDATE SIMPLE ACCOUNTS balance on each new block\n    this.blockSubscription = web3.eth.filter('latest');\n    this.blockSubscription.watch(function(e, res){\n        if(!e) {\n            _this._updateBalance();\n        }\n    });\n};\n\n/**\nUpdates the accounts balances.\n\n@method _updateBalance\n*/\nEthAccounts._updateBalance = function(){\n    var _this = this;\n\n    _.each(EthAccounts.find({}).fetch(), function(account){\n        web3.eth.getBalance(account.address, function(err, res){\n            if(!err) {\n                if(res.toFixed) {\n                    res = res.toFixed();\n                }\n\n                EthAccounts.update(account._id, {\n                    $set: {\n                        balance: res\n                    }\n                });\n            }\n        });\n    });\n}\n\n/**\nUpdates the accounts list,\nif its finds a difference between the accounts in the collection and the accounts in the accounts array.\n\n@method _addAccounts\n*/\nEthAccounts._addAccounts = function(){\n    var _this = this;\n\n    // UPDATE normal accounts on start\n    web3.eth.getAccounts(function(e, accounts){\n        if(!e) {\n            var visibleAccounts = _.pluck(EthAccounts.find().fetch(), 'address');\n\n\n            if(!_.isEmpty(accounts) &&\n                _.difference(accounts, visibleAccounts).length === 0 &&\n                _.difference(visibleAccounts, accounts).length === 0)\n                return;\n\n\n            var localAccounts = EthAccounts.findAll().fetch();\n\n            // if the accounts are different, update the local ones\n            _.each(localAccounts, function(account){\n\n                // needs to have the balance\n                if(!account.balance)\n                    return;\n\n                // set status deactivated, if it seem to be gone\n                if(!_.contains(accounts, account.address)) {\n                    EthAccounts.updateAll(account._id, {\n                        $set: {\n                            deactivated: true\n                        }\n                    });\n                } else {\n                    EthAccounts.updateAll(account._id, {\n                        $unset: {\n                            deactivated: ''\n                        }\n                    });\n                }\n\n                accounts = _.without(accounts, account.address);\n            });\n\n            // ADD missing accounts\n            var accountsCount = visibleAccounts.length + 1;\n            _.each(accounts, function(address){\n\n                web3.eth.getBalance(address, function(e, balance){\n                    if(!e) {\n                        if(balance.toFixed) {\n                            balance = balance.toFixed();\n                        }\n\n                        web3.eth.getCoinbase(function(e, coinbase){\n                            var doc = EthAccounts.findAll({\n                                address: address,\n                            }).fetch()[0];\n\n                            var insert = {\n                                type: 'account',\n                                address: address,\n                                balance: balance,\n                                name: (address === coinbase) ? 'Main account (Etherbase)' : 'Account '+ accountsCount\n                            };\n\n                            if(doc) {\n                                EthAccounts.updateAll(doc._id, {\n                                    $set: insert\n                                });\n                            } else {\n                                EthAccounts.insert(insert);\n                            }\n\n                            if(address !== coinbase)\n                                accountsCount++;\n                        });\n                    }\n                });\n\n            });\n        }\n    });\n};\n\n\n\n/**\nBuilds the query with the addition of \"{deactivated: {$exists: false}}\"\n\n@method _addToQuery\n@param {Mixed} arg\n@param {Object} options\n@param {Object} options.includeDeactivated If set then de-activated accounts are also included.\n@return {Object} The query\n*/\nEthAccounts._addToQuery = function(args, options){\n    var _this = this;\n\n    options = _.extend({\n        includeDeactivated: false\n    }, options);\n\n    var args = Array.prototype.slice.call(args);\n\n    if(_.isString(args[0])) {\n        args[0] = {\n            _id: args[0], \n        };\n    }\n    else if (!_.isObject(args[0])) {\n        args[0] = {};\n    }\n\n    if (!options.includeDeactivated) {\n        args[0] = _.extend(args[0], {\n            deactivated: {$exists: false}\n        });\n    }\n\n    return args;\n};\n\n\n/**\nFind all accounts, besides the deactivated ones\n\n@method find\n@return {Object} cursor\n*/\nEthAccounts.find = function(){    \n    return this._collection.find.apply(this, this._addToQuery(arguments));\n};\n\n/**\nFind all accounts, including the deactivated ones\n\n@method findAll\n@return {Object} cursor\n*/\nEthAccounts.findAll = function() {\n    return this._collection.find.apply(this, this._addToQuery(arguments, {\n        includeDeactivated: true\n    }));\n}\n\n/**\nFind one accounts, besides the deactivated ones\n\n@method findOne\n@return {Object} cursor\n*/\nEthAccounts.findOne = function(){\n    return this._collection.findOne.apply(this, this._addToQuery(arguments));\n};\n\n/**\nUpdate accounts, besides the deactivated ones\n\n@method update\n@return {Object} cursor\n*/\nEthAccounts.update = function(){\n    return this._collection.update.apply(this, this._addToQuery(arguments));\n};\n\n/**\nUpdate accounts, including the deactivated ones\n\n@method updateAll\n@return {Object} cursor\n*/\nEthAccounts.updateAll = function() {\n    return this._collection.update.apply(this, this._addToQuery(arguments, {\n        includeDeactivated: true\n    }));\n}\n\n/**\nUpdate accounts, including the deactivated ones\n\n@method upsert\n@return {Object} cursor\n*/\nEthAccounts.upsert = function() {\n    return this._collection.upsert.apply(this, this._addToQuery(arguments, {\n        includeDeactivated: true\n    }));\n}\n\n\n/**\nStarts fetching and watching the accounts\n\n@method init\n*/\nEthAccounts.init = function() {\n    var _this = this;\n\n    if(typeof web3 === 'undefined') {\n        console.warn('EthAccounts couldn\\'t find web3, please make sure to instantiate a web3 object before calling EthAccounts.init()');\n        return;\n    }\n\n    Tracker.nonreactive(function(){\n\n        _this._addAccounts();\n\n        _this._updateBalance();\n        _this._watchBalance();\n\n        // check for new accounts every 2s\n        Meteor.clearInterval(_this._intervalId);\n        _this._intervalId = Meteor.setInterval(function(){\n            _this._addAccounts();\n        }, 2000);\n\n    });\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ethereum:accounts'] = {}, {\n  EthAccounts: EthAccounts\n});\n\n})();\n","servePath":"/packages/ethereum_accounts.js"}]